---
layout:     post
title:      数学问题总结
subtitle:   Java积累
date:       2018-04-24
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数学问题
    - Java
    - 总结
---

>吃枣药丸

## 不使用加减乘除做加法
```
public int Add1(int num1,int num2) {
  while (num2!=0) {
    int temp = num1^num2;
    num2 = (num1&num2)<<1;
    num1 = temp;
  }
  return num1;
}

public static int Add2(int num1, int num2) {
    BigInteger b1 = new BigInteger(String.valueOf(num1));
    BigInteger b2 = new BigInteger(String.valueOf(num2));
    int sum = b1.add(b2).intValue();
    return sum;
}
```

## 丑数

```
1. 输出第n个丑数
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if (index < 1)
            return 0;
        if (index == 1)
            return 1;
        int a = 0, b = 0, c = 0;
        int[] tmp = new int[index+1];
        tmp[0] = 1;
        for (int i = 1;i < index;i++) {
            tmp[i] = Math.min(Math.min(2*tmp[a], 3*tmp[b]), 5*tmp[c]);
            if (tmp[i] == 2*tmp[a]) {
                a++;
                
            }
            if (tmp[i] == 3*tmp[b]){
                 b++;
                
            }
            if (tmp[i] == 5*tmp[c]){
                c++;
            }
        }
        return tmp[index-1];
    }
}
2.

3.
```

## 素数筛
&emsp;&emsp;快速求指定范围内的所有素数
```
public static Vector<Integer> getPrimeVectorData(int size) {
        boolean[] data = new boolean[size+1];
        for(int i=2; i<=size/2; i++) {
            int factor = 2;
            while(true) {
                if(i*factor<=size) {
                    data[i*factor] = true;
                }
                else {
                    break;
                }
                factor++;
            }
        }
        Vector<Integer> vector = new Vector<>();
        for(int i=2; i<=size; i++) {
            if(data[i] == false)
                vector.add(i);
        }
        return vector;
    }
```

```
public static Map<Integer, Integer> getPrimeVectorData(int size) {
        boolean[] data = new boolean[size+1];
        for(int i=2; i<=size/2; i++) {
            int factor = 2;
            while(true) {
                if(i*factor<=size) {
                    data[i*factor] = true;
                }
                else {
                    break;
                }
                factor++;
            }
        }
        Map<Integer, Integer> mmp = new LinkedHashMap<>();
        for(int i=2; i<=size; i++) {
            if(data[i] == false)
                mmp.put(i, 1);
        }
        return mmp;
    }
```

## 全错排问题  

&emsp;&emsp;一个很经典的数学问题：有一个人写了n封信件，对应n个信封，然而粗心的秘书却把所有信件都装错了信封，那么一共有多少种装错的装法？这个问题可抽象为以下一个数学问题：已知一个长度为n的有序序列｛a1,a2,a3,…,an｝，打乱其顺序，使得每一个元素都不在原位置上，则一共可以产生多少种新的排列？  

&emsp;&emsp;设长度为n的序列的全错位排列一共有f(n)种，假设我们已经解决了f(1)到f(n-1)，那么当序列新增了一个元素an，显然全错位排列中该元素不能放在第n个位置上，假设该元素在从1到n-1的第i个位置，那么在新序列中第n个位置上的元素可能有两种情况：  

- 1.第n个位置上的元素为ai。因为an和ai都不在原位置上，因此只需剩余的元素都是全错位排列，新序列就构成了全错位排列。那么除去ai和an还剩下n-2个元素，则这n-2个元素一共有f(n-2)种全错位排列，因为i的选择共有n-1种，因此该情况下一共有(n-1)*f(n-2)种全错位排列。  

- 2.第n个位置上的元素不为ai。该种情况相当于，前n-1个元素做好了全错位排列，an与其中任意元素交换位置，新生成的序列也是一个全错位排列。这种情况下i的选择共有n-1种，n-1的元素的全错位排列共有f(n-1)种，因此该情况下一共有(n-1)*f(n-1)种全错位排列。  

&emsp;&emsp;综合以上两种情况，f(n)=(n-1)f(n-2)+(n-1)*f(n-1)=(n-1)[f(n-2)+f(n-1)]   


```
public class Main {

    public static void main(String[] args) throws Exception{
        Scanner scanner = new Scanner(System.in);
        String[] data = new String[21];
        data[1] = "0";
        data[2] = "1";
        for(int i=3; i<=20; i++) {
            data[i] = new BigDecimal(String.valueOf(i-1))
                    .multiply(new BigDecimal(data[i-1])
                            .add(new BigDecimal(data[i-2])))
                                .toString();
        }
//        System.out.println(data[size]);
        while (scanner.hasNext()) {
            int tmp = scanner.nextInt();
            System.out.println(data[tmp]);
        }
    }
}
```

## 全排列问题

&emsp;&emsp;字典序法：  

- 从排列的右端开始，找出第一个比右边数字小的数字的序号j（j从左端开始计算）
- 在pj的右边的数字中，找出所有比pj大的数中最小的数字pk，即 k=max{i|pi>pj}（右边的数从右至左是递增的，因此k是所有大于pj的数字中序号最大者）
- 对换pi，pk
- 再将pj+1......pk-1pkpk+1pn倒转得到排列p''=p1p2.....pj-1pjpn.....pk+1pkpk-1.....pj+1，这就是排列p的下一个下一个排列。

&emsp;&emsp;例如839647521是数字1～9的一个排列。从它生成下一个排列的步骤如下：自右至左找出排列中第一个比右边数字小的数字4 839647521;在该数字后的数字中找出比4大的数中最小的一个5 839647521;将5与4交换 839657421;将7421倒转 839651247;所以839647521的下一个排列是839651247。
```
// 字典法
class DictionaryPermutation {

    private char[] data;
    private int length;

    public Vector<String> getPermutateData(String input) {
        Vector<String> vector = new Vector<>();
        // change the data type to we needed
        changeToData(input);
        // sort the data from small to big
        Arrays.sort(data);
        // output all the order
        vector.add(String.valueOf(data));
        while (nextPermutate()) {
            vector.add(String.valueOf(data));
        }
        return vector;
    }

    public void permutate(String input) {
        // change the data type to we needed
        changeToData(input);
        // sort the data from small to big
        Arrays.sort(data);
        // output all the order
        System.out.println(data);
        while (nextPermutate()) {
            System.out.println(data);
        }
    }

    private void changeToData(String input) {
        if (input == null)
            return;
        data = input.toCharArray();
        length = data.length;
    }

    private boolean nextPermutate() {
        int end = length - 1;
        int swapPoint1 = end, swapPoint2 = end;
        // the actual swap-point is swapPoint1 - 1
        while (swapPoint1 > 0 && data[swapPoint1] <= data[swapPoint1 - 1])
            swapPoint1--;
        if (swapPoint1 == 0)
            return false;
        else {
            while (swapPoint2 > 0 && data[swapPoint2] <= data[swapPoint1 - 1])
                swapPoint2--;
            swap(data, swapPoint1 - 1, swapPoint2);
            reverse(data, swapPoint1, end);
            return true;
        }
    }

    private void swap(char[] data, int left, int right) {
        char temp = data[left];
        data[left] = data[right];
        data[right] = temp;
    }

    private void reverse(char[] data, int left, int right) {
        for (int i = left, j = right; i < j; i++, j--)
            swap(data, i, j);
    }

}
```
