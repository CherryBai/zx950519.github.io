---
layout:     post
title:      动态规划总结
subtitle:   DP问题汇总
date:       2018-05-22
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 动态规划
    - 总结
    - 算法
---

## 不同路径

&emsp;&emsp;链接：https://leetcode-cn.com/problems/unique-paths/description/  

![](https://ws1.sinaimg.cn/large/005L0VzSgy1fu0cp794psj30no0idq3o.jpg)  

&emsp;&emsp;典型的数组型DP问题，开二维数组遍历即可，递推公式为:d[i][j] = data[i-1][j] + data[i][j-1];

```
class Solution {
    public int uniquePaths(int m, int n) {
        if(m==1||n==1) 
            return 1;
        int[][] data = new int[m+1][n+1];
        for(int i=1; i<=m; i++) {
            for(int j=1; j<=n; j++) {
                if(i==1&&j==1) {
                    data[i][j] = 1;
                    continue;
                }
                data[i][j] = data[i-1][j] + data[i][j-1];
            }
        }
        return data[m][n];     
    }  
}
```
&emsp;&emsp;其他解法：实际上机器人总共走了m + n - 2步，其中m - 1步向下走，n - 1步向右走，那么总共不同的方法个数就相当于在步数里面m - 1和n - 1中较小的那个数的取法，实际上是一道组合数的问题。  

```
import java.util.*;

class Solution {
    public int uniquePaths(int m, int n) {
        if(m==1||n==1) 
            return 1;
        double num = 1, denom = 1;
        int small = m > n ? n : m;
        for (int i = 1; i <= small - 1; ++i) {
            num *= m + n - 1 - i;
            denom *= i;
        }
        return (int)(num / denom);
    }  
}
```
