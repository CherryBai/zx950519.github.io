---
layout:     post
title:      动态规划总结
subtitle:   DP问题汇总
date:       2018-05-22
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 动态规划
    - 总结
    - 算法
---

## 不同路径

&emsp;&emsp;链接：https://leetcode-cn.com/problems/unique-paths/description/  

![](https://ws1.sinaimg.cn/large/005L0VzSgy1fu0cp794psj30no0idq3o.jpg)  

&emsp;&emsp;典型的数组型DP问题，开二维数组遍历即可，递推公式为:d[i][j] = data[i-1][j] + data[i][j-1];

```
class Solution {
    public int uniquePaths(int m, int n) {
        if(m==1||n==1) 
            return 1;
        int[][] data = new int[m+1][n+1];
        for(int i=1; i<=m; i++) {
            for(int j=1; j<=n; j++) {
                if(i==1&&j==1) {
                    data[i][j] = 1;
                    continue;
                }
                data[i][j] = data[i-1][j] + data[i][j-1];
            }
        }
        return data[m][n];     
    }  
}
```
&emsp;&emsp;其他解法：实际上机器人总共走了m + n - 2步，其中m - 1步向下走，n - 1步向右走，那么总共不同的方法个数就相当于在步数里面m - 1和n - 1中较小的那个数的取法，实际上是一道组合数的问题。  

```
import java.util.*;

class Solution {
    public int uniquePaths(int m, int n) {
        if(m==1||n==1) 
            return 1;
        double num = 1, denom = 1;
        int small = m > n ? n : m;
        for (int i = 1; i <= small - 1; ++i) {
            num *= m + n - 1 - i;
            denom *= i;
        }
        return (int)(num / denom);
    }  
}
```
## 三角形最小路径和

&emsp;&emsp;链接：https://leetcode-cn.com/problems/triangle/description/  

![](https://ws1.sinaimg.cn/large/005L0VzSgy1fu8d99k228j30o60aewev.jpg)  

&emsp;&emsp;矩阵类DP问题：  

```
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        for(int i=0; i<triangle.size(); i++) {
            if(i==0)
                continue;
            List<Integer> tmp = triangle.get(i);
            List<Integer> last = triangle.get(i-1);
            for(int j=0; j<tmp.size(); j++) {
                if(j==0) {
                    tmp.set(j, tmp.get(j)+last.get(0));
                    continue;
                }
                if(j==tmp.size()-1) {
                    tmp.set(j, tmp.get(j)+last.get(last.size()-1));
                    continue;
                }
                int min = Math.min(last.get(j), last.get(j-1));
                tmp.set(j, tmp.get(j)+min);
            }
        }
        List<Integer> last = triangle.get(triangle.size()-1);
        int min = Integer.MAX_VALUE;
        for(int i=0; i<last.size(); i++) 
            if(last.get(i) < min)
                min = last.get(i);
        return min;
    }
}
```

## 最大正方形 

&emsp;&emsp;链接：https://leetcode-cn.com/problems/maximal-square/description/  

![](https://ws1.sinaimg.cn/large/005L0VzSgy1fu8fnlaay6j30of097aa6.jpg)  

```
class Solution {
    public static int maximalSquare(char[][] matrix) {
        if(matrix==null||matrix.length==0||(matrix.length==1&&matrix[0].length==0))
            return 0;
        if(matrix.length==1) {
            for(int i=0; i<matrix[0].length; i++) {
                if(matrix[0][i]=='1')
                    return 1;
            }
            return 0;
        }
        if(matrix[0].length==1) {
            for(int i=0; i<matrix.length; i++) {
                if(matrix[i][0]=='1')
                    return 1;
            }
            return 0;
        }
        int max = 0;
        for(int i=0; i<matrix.length; i++)
            for(int j=0; j<matrix[i].length; j++)
                if(matrix[i][j]=='1')
                    max = 1;
        for(int i=0; i<matrix.length; i++) {
            if(i==0)
                continue;
            for(int j=0; j<matrix[i].length; j++) {
                if(j==0) {
                    continue;
                }
                if(matrix[i][j]=='0') {
                    continue;
                }
                int zs = (int)matrix[i-1][j-1] - (int)('0');
                int ys = (int)matrix[i-1][j] - (int)('0');
                int zx = (int)matrix[i][j-1] - (int)('0');
                int yx = (int)matrix[i][j] - (int)('0');
                System.out.println(zx+" "+ys +" "+zx+" "+yx);
                if(zs>0&&ys>0&&zx>0) {
                    yx += Math.min(Math.min(zs, ys), zx);
                    if(yx > max)
                        max = yx;
                    matrix[i][j] = (char)(yx + '0');
                }
            }
        }
        if(max > 1)
            return max*max;
        else if(max ==1)
            return 1;
        else
            return 0;
    }
}
```
## 最大子序和

&emsp;&emsp;链接：https://leetcode-cn.com/problems/maximum-subarray/description/  

![](http://ww1.sinaimg.cn/large/005L0VzSly1fu9f8gb932j30od07st90.jpg)  

&emsp;&emsp;一维数组的DP问题，状态转移方程为:f(x) = Max(f(x), f(x-1)+f(x))

```
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length==1)
            return nums[0];
        int max = Integer.MIN_VALUE;
        for(int i=1; i<nums.length; i++) {
            nums[i] = Math.max(nums[i], nums[i-1]+nums[i]);
        }
        for(int i=0; i<nums.length; i++) {
            if(nums[i]>max)
                max = nums[i];
        }
        return max;
    }
}
```

## 最小路径和

&emsp;&emsp;链接:https://leetcode-cn.com/problems/minimum-path-sum/description/  

![](http://ww1.sinaimg.cn/large/005L0VzSly1fu9fqqw3hoj30o608ct8u.jpg)  

&emsp;&emsp;二维数组的DP问题，注意边界判断，状态转移方程为f[i][j] = f[i][j] + Math.min(f[i][j-1], f[i-1][j])  


```
class Solution {
    public int minPathSum(int[][] grid) {
        if(grid.length==1) {
            int sum = 0;
            int[] tmp = grid[0];
            for(int i=0; i<tmp.length; i++) {
                sum += tmp[i];
            }
            return sum;
        }
        if(grid[0].length==1) {
            int sum = 0;
            for(int i=0; i<grid.length; i++) {
                sum += grid[i][0];
            }
        }
        for(int i=0; i<grid.length; i++) {
            for(int j=0; j<grid[i].length; j++) {
                if(i==0&&j==0)
                    continue;
                if(i==0&&j!=0){
                    grid[i][j] += grid[i][j-1];
                    continue;
                }
                if(j==0&&i!=0) {
                    grid[i][j] += grid[i-1][j];
                    continue;
                }
                int tmp = Math.min(grid[i][j-1], grid[i-1][j]);
                grid[i][j] += tmp;
            }
        }
        return grid[grid.length-1][grid[0].length-1];
    }
}
```
