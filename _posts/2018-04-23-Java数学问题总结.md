---
layout:     post
title:      数学问题总结
subtitle:   Java积累
date:       2018-04-24
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数学问题
    - Java
    - 总结
---

>吃枣药丸

## 不使用加减乘除做加法
```
public int Add1(int num1,int num2) {
  while (num2!=0) {
    int temp = num1^num2;
    num2 = (num1&num2)<<1;
    num1 = temp;
  }
  return num1;
}

public static int Add2(int num1, int num2) {
    BigInteger b1 = new BigInteger(String.valueOf(num1));
    BigInteger b2 = new BigInteger(String.valueOf(num2));
    int sum = b1.add(b2).intValue();
    return sum;
}
```
## 丑数

```
1. 输出第n个丑数
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if (index < 1)
            return 0;
        if (index == 1)
            return 1;
        int a = 0, b = 0, c = 0;
        int[] tmp = new int[index+1];
        tmp[0] = 1;
        for (int i = 1;i < index;i++) {
            tmp[i] = Math.min(Math.min(2*tmp[a], 3*tmp[b]), 5*tmp[c]);
            if (tmp[i] == 2*tmp[a]) {
                a++;
                
            }
            if (tmp[i] == 3*tmp[b]){
                 b++;
                
            }
            if (tmp[i] == 5*tmp[c]){
                c++;
            }
        }
        return tmp[index-1];
    }
}
2.

3.
```

## 素数筛

```
public static Vector<Integer> getPrimeVectorData(int size) {
        boolean[] data = new boolean[size+1];
        for(int i=2; i<=size/2; i++) {
            int factor = 2;
            while(true) {
                if(i*factor<=size) {
                    data[i*factor] = true;
                }
                else {
                    break;
                }
                factor++;
            }
        }
        Vector<Integer> vector = new Vector<>();
        for(int i=2; i<=size; i++) {
            if(data[i] == false)
                vector.add(i);
        }
        return vector;
    }
```

```
public static Map<Integer, Integer> getPrimeVectorData(int size) {
        boolean[] data = new boolean[size+1];
        for(int i=2; i<=size/2; i++) {
            int factor = 2;
            while(true) {
                if(i*factor<=size) {
                    data[i*factor] = true;
                }
                else {
                    break;
                }
                factor++;
            }
        }
        Map<Integer, Integer> mmp = new LinkedHashMap<>();
        for(int i=2; i<=size; i++) {
            if(data[i] == false)
                mmp.put(i, 1);
        }
        return mmp;
    }
```
