---
layout:     post
title:      牛客网刷题笔记
subtitle:   牛客网刷题备忘录
date:       2018-04-22
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 牛客网
    - Java
    - 总结
---

> 不积跬步 无以至千里 吾将上下而求索

## 二维数组中的查找
题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
```
public class Solution {
    public boolean Find(int target, int [][] array) {
        for(int i=0;i<array.length;i++){
            for(int j=0;j<array[0].length;j++){
                if(array[i][j]==target)
                    return true;
                if(array[i][j]>target){
                    break;
                }
            }
        }
        return false;
    }
}
```

## 替换空格
题目描述
请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
```
public class Solution {
    public String replaceSpace(StringBuffer str) {
        while(str.indexOf(" ")!=-1){
            int indexSpace = str.indexOf(" ");
            str.replace(indexSpace, indexSpace + 1, "%20");
        }
        return str.toString();
    }
}
```

## 从尾到头打印链表
题目描述
输入一个链表，从尾到头打印链表每个节点的值。
```
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        
        if(listNode==null)
            return new ArrayList();
        ArrayList<Integer> ans = new ArrayList();
        if(listNode.next==null){
            ans.add(listNode.val);
            return ans;
        }
        Stack<Integer> stack = new Stack();
        while(listNode!=null){
            stack.push(listNode.val);
            listNode = listNode.next;
        }
        while(!stack.empty()){
            ans.add(stack.pop());
        }
        return ans;
    }
}
```

## 二叉树的镜像
题目描述
操作给定的二叉树，将其变换为源二叉树的镜像
```
public class Solution {
    public void Mirror(TreeNode root) {
        if(root==null)
            return;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        Mirror(root.left);
        Mirror(root.right);
    }
}
```

## 反转列表
题目描述
输入一个链表，反转链表后，输出链表的所有元素。
```
import java.util.Stack;
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head==null)
            return null;
        if(head.next==null)
            return head;
        
        Stack<Integer> stack = new Stack();
        ListNode tmp = head;
        while(tmp != null){
            stack.push(tmp.val);
            tmp = tmp.next;
        }
        tmp = head;
        while(tmp != null){
            tmp.val = stack.pop();
            tmp = tmp.next;
        }
        return head;
    }
}
```

## 斐波那契数列
题目描述
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。
```
public class Solution {
    public int Fibonacci(int n) {
        if(n == 0)
            return 0;
        if(n == 1)
            return 1;
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    }
}
```

## 合并两个排序的链表
题目描述
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
```
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list2 == null)
            return list1;
        if(list1 == null)
            return list2;
        if(list1 == null && list2 == null)
            return null;
        ListNode ans = new ListNode(-1);
        ListNode tmp = ans;
        ListNode cur1 = list1;
        ListNode post1 = list1.next;
        ListNode cur2 = list2;
        ListNode post2 = list2.next;
        
        while(cur1 != null && cur2 != null){
            if(cur1.val < cur2.val){
                tmp.next = cur1;
                tmp = tmp.next;
                cur1 = cur1.next;
            }else{
                tmp.next = cur2;
                tmp = tmp.next;
                cur2 = cur2.next;
            }
        }
        if(cur1 != null){
            tmp.next = cur1;
        }
        if(cur2 != null){
            tmp.next = cur2;
        }
        return ans.next;
    }
}
```

## 链表中倒数第k个结点
题目描述
输入一个链表，输出该链表中倒数第k个结点。
```
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head == null)
            return null;
        if(k == 0)
            return null;
        ListNode tmp = head;
        ListNode ans = head;
        int sum = 0, flag = k;
        while(tmp.next != null){
            if(k <= 1){
                ans = ans.next;
            }else{
                k--;
            }
            if(tmp.next != null)
                tmp = tmp.next;
            else 
                break;
        }
        if(k > 1)
            return null;
        return ans;
    }
}
```

## 从上往下打印二叉树
题目描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
```
import java.util.*;
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList<Integer> ans = new ArrayList();
        Queue<TreeNode> queue = new LinkedList();
        queue.offer(root);
        while(queue.peek() != null){
            TreeNode tmp = queue.poll();
            ans.add(tmp.val);
            if(tmp.left != null)
                queue.offer(tmp.left);
            if(tmp.right != null)
                queue.offer(tmp.right);
        }
        return ans;
    }
}
```
## 最小的K个数
题目描述
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
```
import java.util.*;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        if(k == 0 || k > input.length)
            return new ArrayList();
        
        ArrayList<Integer> tmp = new ArrayList();
        for(int i=0;i<input.length;i++){
            tmp.add(input[i]);
        }
        Collections.sort(tmp);
        ArrayList<Integer> ans = new ArrayList();
        for(int i=0;i<k;i++)
            ans.add(tmp.get(i));
        return ans;
    }
}
```

## 数组中出现次数超过一半的数字
题目描述
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
```
import java.util.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        Map<Integer, Integer> mmp = new HashMap();
        for(int i=0;i<array.length;i++)
            mmp.put(array[i], mmp.getOrDefault(array[i], 0)+1);
        int ans = 0;
        for(Map.Entry<Integer, Integer> entry: mmp.entrySet())
            if(entry.getValue() > array.length/2)
                ans = entry.getKey();
        return ans;
    }
}
```

## 调整数组顺序使奇数位于偶数前面
题目描述
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，
所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
```
import java.util.*;
public class Solution {
    public void reOrderArray(int [] array) {
        Queue<Integer> odd = new LinkedList();
        Queue<Integer> even = new LinkedList();
        for (int i = 0;i < array.length;i++) {
            if(array[i]%2 == 0)
                even.offer(array[i]);
            else
                odd.offer(array[i]);
        }
        int index = 0;
        while(odd.peek() != null) {
            array[index++] = odd.poll();
        }
        while(even.peek() != null) {
            array[index++] = even.poll();
        }
    }
}
```

## 树的子结构
题目描述
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
```
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root2==null) 
            return false;
        if(root1==null && root2!=null) 
            return false;
        boolean flag = false;
        if(root1.val == root2.val)
            flag = isSubTree(root1, root2);
        if(flag == false){
            flag = HasSubtree(root1.left, root2);
            if(flag == false)
                flag = HasSubtree(root1.right, root2);
        }
        return flag;
    }
    
    public boolean isSubTree(TreeNode root1,TreeNode root2) {
        if(root2 == null)
            return true;
        if(root1==null && root2!=null)
            return false;
        if(root1.val != root2.val)
            return false;
        else
            return isSubTree(root1.left, root2.left) && isSubTree(root1.right, root2.right);
    }
}
```

## 求1+2+3+...+n
题目描述
求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
```
public class Solution {
    public int sum = 0;
    public int Sum_Solution(int n) {
        return func(n);
    }
    public int func (int n) {
        if(n==0)
            return 0;
        return n + func(n-1);
    }
}
```
## 二叉树的深度
题目描述
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
```
import java.util.*;
import java.math.*;
public class Solution {
    public int TreeDepth(TreeNode root) {
        if (root == null)
            return 0;
        return 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
    }
}
```
## 左旋转字符串
题目描述
汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，
就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，
请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,
要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！
```
import java.lang.*;
public class Solution {
    public String LeftRotateString(String str,int n) {
        if(n == 0)
            return str;
        if(n > str.length())
            return "";
        String substr1 = str.substring(0, n);
        int len = str.length();
        String substr2 = str.substring(n, len);
        return substr2 + substr1;
    }
}
```

## 和为S的两个数字
题目描述
输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
```
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
        int multy = 214748364;
        int num1 = 0, num2 = 0;
        boolean flag = false;
        ArrayList<Integer> ai = new ArrayList();
        for (int i = 0;i < array.length;i++) {
            for (int j = i+1;j < array.length;j++) {
                if (array[i] + array[j] == sum) {
                    flag = true;
                    if (multy > array[i]*array[j]) {
                        multy = array[i]*array[j];
                        num1 = array[i];
                        num2 = array[j];
                    }
                }
            }
        }
        if (flag == false) {
            return new ArrayList<Integer>();
        }
        ai.add(num1);
        ai.add(num2);
        return ai;
    }
}
```
## 数组中重复的数字
题目描述
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。
```
import java.util.*;
public class Solution {
    // Parameters:
    //    numbers:     an array of integers
    //    length:      the length of array numbers
    //    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;
    //                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++
    //    这里要特别注意~返回任意重复的一个，赋值duplication[0]
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        
        if(length <= 1){
            //duplication[0] = -1;
            return false;
        }
            
        Map<Integer, Integer> mmp = new HashMap();
        for (int i = 0;i < numbers.length;i++) {
            mmp.put(numbers[i], mmp.getOrDefault(numbers[i], 0) + 1);
        }
        int count = 0;
        for (Map.Entry entry : mmp.entrySet()) {
            int p = (int)entry.getValue();
            if(p - 1 > 0){
                duplication[count++] = (int)entry.getKey();
                return true;
            }
        }
        return false;
    }
}
```
## 对称的二叉树
题目描述
请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
```
public class Solution {
    boolean isSymmetrical(TreeNode pRoot) {
        if (pRoot == null)
            return true;
        return func(pRoot.left, pRoot.right);
    }
    boolean func (TreeNode r1, TreeNode r2) {
        
        if(r1==null && r2==null)
            return true;
        if(r1==null || r2==null)
            return false;
        return r1.val==r2.val && func(r1.left, r2.right) && func(r1.right, r2.left);
    }
}
```
## 旋转数组的最小数字
题目描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
```
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length == 0) {
            return 0;
        }
        int ans = 0;
        for (int i = 0; i < array.length-1;i++) {
            if(array[i] <= array[i+1])
                continue;
            else{
                ans = i + 1;
                break;
            }
        }
        return array[ans];
    }
}
```

## 丑数
题目描述
把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
```
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if (index < 1)
            return 0;
        if (index == 1)
            return 1;
        int a = 0, b = 0, c = 0;
        int[] tmp = new int[index+1];
        tmp[0] = 1;
        for (int i = 1;i < index;i++) {
            tmp[i] = Math.min(Math.min(2*tmp[a], 3*tmp[b]), 5*tmp[c]);
            if (tmp[i] == 2*tmp[a]) {
                a++;
                
            }
            if (tmp[i] == 3*tmp[b]){
                 b++;
                
            }
            if (tmp[i] == 5*tmp[c]){
                c++;
            }
        }
        return tmp[index-1];
    }
}
```

## 两个链表的第一个公共结点
题目描述
输入两个链表，找出它们的第一个公共结点。
```
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        int len1 = 0, len2 = 0;
        ListNode tmp1 = pHead1, tmp2 = pHead2;
        while (tmp1 != null) {
            len1++;
            tmp1 = tmp1.next;
        }
        while (tmp2 != null) {
            len2++;
            tmp2 = tmp2.next;
        }
        tmp1 = pHead1;
        tmp2 = pHead2;
        if (len1 > len2) {
            int len = len1 - len2;
            while (len > 0) {
                tmp1 = tmp1.next;
                len--;
            }
        }else if (len2 > len1) {
            int len = len2 - len1;
            while (len > 0) {
                tmp2 = tmp2.next;
                len--;
            }
        }else{
            //等长 不处理
        }
        while (tmp1!=null && tmp2!=null) {
            if (tmp1 == tmp2) {
                return tmp1;
            }
            else{
                tmp1 = tmp1.next;
                tmp2 = tmp2.next;
            }
        }
        
        
        return null;
    }
}
```

## 数字在排序数组中出现的次数
题目描述
统计一个数字在排序数组中出现的次数。
```
import java.util.*;
public class Solution {
    public int GetNumberOfK(int [] array , int k) {
        Map<Integer, Integer> data = new HashMap();
        for (int i=0;i<array.length;i++) {
            data.put(array[i], data.getOrDefault(array[i], 0) + 1);
        }
        return data.getOrDefault(k, 0);
    }
}
```
## 数组中只出现一次的数字
题目描述
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
```
import java.util.*;
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        Map<Integer, Integer> data = new HashMap();
        for (int i=0;i<array.length;i++) {
            data.put(array[i], data.getOrDefault(array[i], 0) + 1);
        }
        int flag = 0;
        for (Map.Entry<Integer, Integer> entry : data.entrySet()) {
            if (entry.getValue() == 1) {
                if (flag == 0) {
                    num1[0] = entry.getKey();
                    flag++;
                }
                else{
                    num2[0] = entry.getKey();
                }
            }
        }
    }
}
```

## 把二叉树打印成多行
题目描述
从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
```
import java.util.ArrayList;


/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.*;
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        Queue<TreeNode> queue1 = new LinkedList();
        Queue<TreeNode> queue2 = new LinkedList();
        ArrayList<ArrayList<Integer>> data = new ArrayList();
        queue1.offer(pRoot);
        while (queue1.peek()!=null || queue2.peek()!=null) {
            if (queue1.peek() != null) {
                ArrayList<Integer> tmp = new ArrayList();
                while (queue1.peek() != null) {
                    TreeNode node = queue1.poll();
                    tmp.add(node.val);
                    if (node.left != null)
                        queue2.offer(node.left);
                    if (node.right != null)
                        queue2.offer(node.right);
                }
                data.add(tmp);
            }
            else if (queue2.peek() != null) {
                ArrayList<Integer> tmp = new ArrayList();
                while (queue2.peek() != null) {
                    TreeNode node = queue2.poll();
                    tmp.add(node.val);
                    if (node.left != null)
                        queue1.offer(node.left);
                    if (node.right != null)
                        queue1.offer(node.right);
                }
                data.add(tmp);
            }
            else {
                break;
            }
        }
        return data;
    }
    
}
```

## 数据流中的中位数
题目描述
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
```
import java.util.*;
public class Solution {
    
    public ArrayList<Integer> data = new ArrayList();
    
    public void Insert(Integer num) {
        data.add(num);
    }
    public Double GetMedian() {
        if (data.size() ==1) {
            return Double.valueOf(data.get(0).toString());
            //return data.get(0);
        }
        Collections.sort(data);
        double ans = 0;
        if (data.size() %2 == 1) {
            return (double)data.get(data.size() / 2);
        }
        else if (data.size() %2 == 0) {
            ans = (double)(data.get(data.size()/2) + data.get(data.size()/2-1)) / 2;
            return ans;
        }
        return Double.valueOf("0");
    }
}
```
## 二叉搜索树的第k个结点
题目描述
给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。
```
import java.util.*;
public class Solution {
    public TreeNode result;
    public int num = 0;
    TreeNode KthNode(TreeNode pRoot, int k) {
        num = k;
        func(pRoot);
        return result;
    }
    void func (TreeNode pRoot) {
        if (pRoot == null)
            return;
        func(pRoot.left);
        num--;
        if (num == 0) {
            result = pRoot;
        }
        func(pRoot.right);
    }

}
```
## 跳台阶
题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
```
public class Solution {
    public int JumpFloor(int target) {
        if (target <= 0) 
            return 0;
        else if (target == 1) 
            return 1;
        else if (target == 2) 
            return 2;
        else 
            return JumpFloor(target-1) + JumpFloor(target-2);
    }
}
```

## 变态跳台阶
题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
```
public class Solution {
    public int JumpFloorII(int target) {
        if (target <= 0) {
            return 0;
        }
        if (target <= 2) {
            return target;
        }
        else {
            return JumpFloorII(target -1) * 2;
        }
    }
}
```
## 用两个栈实现队列
题目描述
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
```
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        if (stack1.isEmpty()) {
            stack2.push(node);
        }else {
            stack1.push(node);
        }
    }
    
    public int pop() {
        if (stack1.isEmpty()) {
            while (!stack2.isEmpty()) {
                stack1.push(stack2.pop());
            }
            int data = stack1.pop();
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
            return data;
        }else {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
            int data = stack2.pop();
            while (!stack2.isEmpty()) {
                stack1.push(stack2.pop());
            }
            return data;
        }
    }
}
```
## 矩形覆盖
题目描述
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
```
public class Solution {
    public int RectCover(int target) {
        if (target <= 2) 
            return target;
        int[] data = new int[target+1];
        data[1] = 1;
        data[2] = 2;
        for (int i=3;i<=target;i++) {
            data[i] = data[i-1] + data[i-2];
        }
        return data[target];
    }
}
```

## 包含min函数的栈
题目描述
定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。
```
import java.util.Stack;

public class Solution {

    Stack<Integer> stack = new Stack();
    Stack<Integer> stack_tmp = new Stack();
    int min = Integer.MAX_VALUE;
    public void push(int node) {
        if (node < min) 
            min = node;
        stack.push(node);
    }
    
    public void pop() {
        stack.pop();
        min = Integer.MAX_VALUE;
        while (!stack.isEmpty()) {
            if (stack.peek() < min)
                min = stack.peek();
            stack_tmp.push(stack.pop());
        }
        while (!stack_tmp.isEmpty()) {
            stack.push(stack_tmp.pop());
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return min;
    }
}
```

## 平衡二叉树
题目描述
输入一棵二叉树，判断该二叉树是否是平衡二叉树。
```
import java.util.*;
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) 
            return true;
        
        if (Math.abs(getTreeHeight(root.left) - getTreeHeight(root.right)) > 1) 
            return false;
        else 
            return IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right);
    }
    
    public int getTreeHeight(TreeNode root) {
        if (root == null) 
            return 0;
        return 1 + Math.max(getTreeHeight(root.left), getTreeHeight(root.right));
    }
}
```

## 把字符串转换成整数
题目描述
将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0
```
public class Solution {
    public int StrToInt(String str) {
        
       if (str.equals("") || str.length() == 0)
            return 0;
        
        char[] data = str.toCharArray();
        int flag = 0;
        if (data[0] == '-')
            flag = 1;
        int sum = 0;
        for (int i = flag; i < data.length; i++)
        {
            if (data[i] == '+')
                continue;
            if (data[i] < 48 || data[i] > 57)
                return 0;
            sum = sum * 10 + data[i] - 48;
        }
        return flag == 0 ? sum : sum * -1;
    }
}
```

## 整数中1出现的次数（从1到n整数中1出现的次数）
题目描述
求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。
```
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        int count=0;
        if (n < 1) 
            return 0;
        for (int i=1;i<=n;++i) {
            int temp=i;
            while (temp > 0) {
                if (temp%10 == 1) 
                    ++count;
                temp/=10;
            }
        }
        return count;
    }
}
```
```
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        int count=0;
        while(n>0){
            String str=String.valueOf(n);
            char [] chars=str.toCharArray();
            for(int i=0;i<chars.length;i++){
                if(chars[i]=='1')
                    count++;
            }
            n--;
        }
        return count;
    }
}
```

## 连续子数组的最大和
题目描述
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)
```
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        int max = Integer.MIN_VALUE;
        int max_absoluate = Integer.MIN_VALUE;
        for (int i=0;i<array.length;i++) {
            int tmp = array[i];
            if (array[i] > max) 
                max = array[i];
            for (int j=i+1;j<array.length;j++) {
                if (tmp + array[j] > max) {
                    max = tmp + array[j];
                }
                tmp += array[j];
            }
        }
        return max > max_absoluate ? max : max_absoluate;
    }
}
```

## 二叉树中序遍历的下一个结点
题目描述
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
```
解释：
节点可以分成两大类：
1、有右子树的，那么下个结点就是右子树最左边的点
2、没有右子树的，也可以分成两类：
    a)是父节点左孩子 ，那么父节点就是下一个节点
    b)是父节点的右孩子找他的父节点的父节点的父节点...直到当前结点是其父节点的左孩子位置。如果没有，那么他就是尾节点。
```
```
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        if (pNode == null) 
            return null;
        if (pNode.right!=null) {
            return visit(pNode.right);
        }
        while (pNode.next != null) {
            if (pNode.next.left == pNode) 
                return pNode.next;
            pNode = pNode.next;
        }
        return null;
    }
    
    public TreeLinkNode visit(TreeLinkNode pNode) {
        if (pNode.left != null)
            pNode = pNode.left;
        return pNode;
    }
}
```
## 字符流中第一个不重复的字符
题目描述
请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。
```
import java.util.*;
public class Solution {
    //Insert one char from stringstream
    List<Character> data = new ArrayList();
    public void Insert(char ch){
        data.add(ch);
    }
  //return the first appearence once char in current stringstream
    public char FirstAppearingOnce(){
        Map<Character, Integer> mmp = new HashMap();
        for (int i=0;i<data.size();i++) {
            mmp.put(data.get(i), mmp.getOrDefault(data.get(i), 0) + 1);
        }
        char ans = '#';
        for (int i=0;i<data.size();i++) {
            if (mmp.getOrDefault(data.get(i), 0) == 1) {
                ans = data.get(i);
                break;
            }
        }
        return ans;
    }
}
```
## 滑动窗口的最大值
题目描述
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
```
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size) {
        if (num.length==0 || num.length < size || size == 0) 
            return new ArrayList();
        
        ArrayList<Integer> data = new ArrayList();
        for (int i=0; i<=num.length-size; i++) {
            int tmp = Integer.MIN_VALUE;
            for (int j=i; j<i+size; j++) {
                if (num[j]>tmp) 
                    tmp = num[j];
            }
            data.add(tmp);
        }
        return data;
    }
}
```
## 按之字形顺序打印二叉树
题目描述
请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
```
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> data = new ArrayList();
        Queue<TreeNode> q1 = new LinkedList();
        Queue<TreeNode> q2 = new LinkedList();
        Stack<TreeNode> s = new Stack();
        q1.offer(pRoot);
        while (q1.peek()!=null || q2.peek()!=null) {
            ArrayList<Integer> tmp = new ArrayList();
            if (q1.peek()!= null) {
                while (q1.peek()!=null) {
                    tmp.add(q1.peek().val);
                    if (q1.peek().left != null)
                        q2.offer(q1.peek().left);
                    if (q1.peek().right != null)
                        q2.offer(q1.peek().right);
                    q1.poll();
                }
            }
            else {
                while (q2.peek()!=null) {
                    s.push(q2.peek());
                    if (q2.peek().left != null)
                        q1.offer(q2.peek().left);
                    if (q2.peek().right != null)
                        q1.offer(q2.peek().right);
                    q2.poll();
                }
                while (!s.empty()) {
                    tmp.add(s.pop().val);
                }
            }
            data.add(tmp);
        }
        return data;
    }
}
```

## 和为S的连续正数序列
题目描述
小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
```
import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
        ArrayList<ArrayList<Integer>> data = new ArrayList();
       for (int i=1; i<=sum/2; i++) {
           ArrayList<Integer> tmp = new ArrayList();
           int trys = 0;
           for (int j=i; j<=sum/2+1; j++) {
               trys += j;
               if (trys == sum) {
                   for (int k=i; k<=j; k++)
                       tmp.add(k);
                   break;
               }
               if (trys > sum) {
                   break;
               }
               
           }
           if (tmp.size() != 0) 
               data.add(tmp);
       }
        return data;
    }
}
```

## 删除链表中重复的结点
题目描述
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
```
import java.util.*;
public class Solution {
    public ListNode deleteDuplication(ListNode pHead) {
        Map<Integer, Integer> data = new HashMap();
        ArrayList<Integer> da = new ArrayList();
        ListNode tmp = pHead;
        while (tmp != null) {
            data.put(tmp.val, data.getOrDefault(tmp.val, 0)+1);
            tmp = tmp.next;
        }
        for (Map.Entry<Integer, Integer> entry:data.entrySet()) {
            if (entry.getValue() == 1)
                da.add(entry.getKey());
        }
        if (da.size() == 0) 
            return null;
        Collections.sort(da);
        tmp = pHead;
        int flag = da.size();
        while (tmp != null) {
            tmp.val = da.get(da.size() - flag);
            flag--;
            if (flag == 0) {
                tmp.next = null;
                break;
            }
            tmp = tmp.next;
        }
        return pHead;
    }
}
```
## 孩子们的游戏(圆圈中最后剩下的数)
题目描述
每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)
```
import java.util.*;
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        //Map<Integer, Integer> data = new HashMap();
        //for (int i=0;i<n;i++) {
            //data.put(i, 0);
        //}
        if(n<1 || m<1) 
            return -1;
        
        int[] data = new int[n];
        int i = -1, step = 0, count = n;
        while (count >0) {
            i++;
            if (i == n) 
                i = 0;
            if (data[i] == Integer.MIN_VALUE)
                continue;
            step++;
            if (step==m) {
                data[i] = Integer.MIN_VALUE;
                step = 0;
                count--;
            }
        }
        return i;
    }
}
```
```
if(n==0||m==0)return -1;
    int s=0;
    for(int i=2;i<=n;i++) {
        s=(s+m)%i;
    }   
    return s ;
 ```      
