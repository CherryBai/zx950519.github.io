---
layout:     post
title:      牛客网刷题笔记
subtitle:   牛客网刷题备忘录
date:       2018-04-22
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 牛客网
    - Java
    - 总结
---

> 不积跬步 无以至千里 吾将上下而求索

## 二维数组中的查找
题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
```
public class Solution {
    public boolean Find(int target, int [][] array) {
        for(int i=0;i<array.length;i++){
            for(int j=0;j<array[0].length;j++){
                if(array[i][j]==target)
                    return true;
                if(array[i][j]>target){
                    break;
                }
            }
        }
        return false;
    }
}
```

## 替换空格
题目描述
请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
```
public class Solution {
    public String replaceSpace(StringBuffer str) {
        while(str.indexOf(" ")!=-1){
            int indexSpace = str.indexOf(" ");
            str.replace(indexSpace, indexSpace + 1, "%20");
        }
        return str.toString();
    }
}
```

## 从尾到头打印链表
题目描述
输入一个链表，从尾到头打印链表每个节点的值。
```
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        
        if(listNode==null)
            return new ArrayList();
        ArrayList<Integer> ans = new ArrayList();
        if(listNode.next==null){
            ans.add(listNode.val);
            return ans;
        }
        Stack<Integer> stack = new Stack();
        while(listNode!=null){
            stack.push(listNode.val);
            listNode = listNode.next;
        }
        while(!stack.empty()){
            ans.add(stack.pop());
        }
        return ans;
    }
}
```

## 二叉树的镜像
题目描述
操作给定的二叉树，将其变换为源二叉树的镜像
```
public class Solution {
    public void Mirror(TreeNode root) {
        if(root==null)
            return;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        Mirror(root.left);
        Mirror(root.right);
    }
}
```

## 反转列表
题目描述
输入一个链表，反转链表后，输出链表的所有元素。
```
import java.util.Stack;
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head==null)
            return null;
        if(head.next==null)
            return head;
        
        Stack<Integer> stack = new Stack();
        ListNode tmp = head;
        while(tmp != null){
            stack.push(tmp.val);
            tmp = tmp.next;
        }
        tmp = head;
        while(tmp != null){
            tmp.val = stack.pop();
            tmp = tmp.next;
        }
        return head;
    }
}
```

## 斐波那契数列
题目描述
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。
```
public class Solution {
    public int Fibonacci(int n) {
        if(n == 0)
            return 0;
        if(n == 1)
            return 1;
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    }
}
```

## 合并两个排序的链表
题目描述
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
```
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list2 == null)
            return list1;
        if(list1 == null)
            return list2;
        if(list1 == null && list2 == null)
            return null;
        ListNode ans = new ListNode(-1);
        ListNode tmp = ans;
        ListNode cur1 = list1;
        ListNode post1 = list1.next;
        ListNode cur2 = list2;
        ListNode post2 = list2.next;
        
        while(cur1 != null && cur2 != null){
            if(cur1.val < cur2.val){
                tmp.next = cur1;
                tmp = tmp.next;
                cur1 = cur1.next;
            }else{
                tmp.next = cur2;
                tmp = tmp.next;
                cur2 = cur2.next;
            }
        }
        if(cur1 != null){
            tmp.next = cur1;
        }
        if(cur2 != null){
            tmp.next = cur2;
        }
        return ans.next;
    }
}
```

## 链表中倒数第k个结点
题目描述
输入一个链表，输出该链表中倒数第k个结点。
```
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head == null)
            return null;
        if(k == 0)
            return null;
        ListNode tmp = head;
        ListNode ans = head;
        int sum = 0, flag = k;
        while(tmp.next != null){
            if(k <= 1){
                ans = ans.next;
            }else{
                k--;
            }
            if(tmp.next != null)
                tmp = tmp.next;
            else 
                break;
        }
        if(k > 1)
            return null;
        return ans;
    }
}
```

## 从上往下打印二叉树
题目描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
```
import java.util.*;
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList<Integer> ans = new ArrayList();
        Queue<TreeNode> queue = new LinkedList();
        queue.offer(root);
        while(queue.peek() != null){
            TreeNode tmp = queue.poll();
            ans.add(tmp.val);
            if(tmp.left != null)
                queue.offer(tmp.left);
            if(tmp.right != null)
                queue.offer(tmp.right);
        }
        return ans;
    }
}
```
## 最小的K个数
题目描述
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
```
import java.util.*;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        if(k == 0 || k > input.length)
            return new ArrayList();
        
        ArrayList<Integer> tmp = new ArrayList();
        for(int i=0;i<input.length;i++){
            tmp.add(input[i]);
        }
        Collections.sort(tmp);
        ArrayList<Integer> ans = new ArrayList();
        for(int i=0;i<k;i++)
            ans.add(tmp.get(i));
        return ans;
    }
}
```

## 数组中出现次数超过一半的数字
题目描述
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
```
import java.util.*;
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        Map<Integer, Integer> mmp = new HashMap();
        for(int i=0;i<array.length;i++)
            mmp.put(array[i], mmp.getOrDefault(array[i], 0)+1);
        int ans = 0;
        for(Map.Entry<Integer, Integer> entry: mmp.entrySet())
            if(entry.getValue() > array.length/2)
                ans = entry.getKey();
        return ans;
    }
}
```

## 调整数组顺序使奇数位于偶数前面
题目描述
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，
所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
```
import java.util.*;
public class Solution {
    public void reOrderArray(int [] array) {
        Queue<Integer> odd = new LinkedList();
        Queue<Integer> even = new LinkedList();
        for (int i = 0;i < array.length;i++) {
            if(array[i]%2 == 0)
                even.offer(array[i]);
            else
                odd.offer(array[i]);
        }
        int index = 0;
        while(odd.peek() != null) {
            array[index++] = odd.poll();
        }
        while(even.peek() != null) {
            array[index++] = even.poll();
        }
    }
}
```

## 树的子结构
题目描述
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
```
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root2==null) 
            return false;
        if(root1==null && root2!=null) 
            return false;
        boolean flag = false;
        if(root1.val == root2.val)
            flag = isSubTree(root1, root2);
        if(flag == false){
            flag = HasSubtree(root1.left, root2);
            if(flag == false)
                flag = HasSubtree(root1.right, root2);
        }
        return flag;
    }
    
    public boolean isSubTree(TreeNode root1,TreeNode root2) {
        if(root2 == null)
            return true;
        if(root1==null && root2!=null)
            return false;
        if(root1.val != root2.val)
            return false;
        else
            return isSubTree(root1.left, root2.left) && isSubTree(root1.right, root2.right);
    }
}
```

## 求1+2+3+...+n
题目描述
求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
```
public class Solution {
    public int sum = 0;
    public int Sum_Solution(int n) {
        return func(n);
    }
    public int func (int n) {
        if(n==0)
            return 0;
        return n + func(n-1);
    }
}
```
## 二叉树的深度
题目描述
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
```
import java.util.*;
import java.math.*;
public class Solution {
    public int TreeDepth(TreeNode root) {
        if (root == null)
            return 0;
        return 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
    }
}
```
## 左旋转字符串
题目描述
汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，
就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，
请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,
要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！
```
import java.lang.*;
public class Solution {
    public String LeftRotateString(String str,int n) {
        if(n == 0)
            return str;
        if(n > str.length())
            return "";
        String substr1 = str.substring(0, n);
        int len = str.length();
        String substr2 = str.substring(n, len);
        return substr2 + substr1;
    }
}
```
