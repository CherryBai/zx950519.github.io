---
layout:     post
title:      Java多线程核心技术阅读笔记
subtitle:   阅读笔记
date:       2018-04-27
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Java多线程核心技术
    - Java
    - 读书笔记
---
> 不积跬步 无以至千里

## 概念

#### 进程和线程的定义
- 进程:具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。
- 线程:进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,
只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

#### 进程和线程的关系
- 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。
- 相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
下图为线程和进程关系的直观表示：  

![Markdown](http://i4.bvimg.com/643127/014f4b5106ab1239.png)  

#### 进程和线程的区别
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，
而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，
所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，
只能用线程，不能用进程。
- 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。
- 线程的划分尺度小于进程，使得多线程程序的并发性高。
- 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
- 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，
必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，
来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

#### 实例1
- 下面的例子显示了Thread类能打印的一些信息，比较值得注意的是线程名、线程ID。
```   

public static void main(String[] args) {
    System.out.println(Thread.currentThread().getName());
    System.out.println(Thread.currentThread().getId());
    System.out.println(Thread.currentThread().getPriority());
    System.out.println(Thread.currentThread().getContextClassLoader());
    System.out.println(Thread.currentThread().getStackTrace());
    System.out.println(Thread.currentThread().getState());
    System.out.println(Thread.currentThread().getThreadGroup());
    System.out.println(Thread.currentThread().getClass());
}
```

#### 实例2
- 按常规思维，Mythread应该优先于运行结束被打印，但是实际执行中会存在相反的打印顺序，
这说明在使用多线程技术时，代码的运行结果与代码执行顺序或调用顺序是无关的。
- 线程是一个子任务，CPU以不确定的方式，或者说随机的时间来调用线程中的run方法。  

```
public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();// 这里如果换成run()的话就是同步执行，否则是异步执行
    System.out.println("运行结束！");    
}
class MyThread extends Thread {
    public void run () {
        super.run(); 
        System.out.println("Mythread");
    }
}
```

#### 实例3
根据Thread构造函数，传入Runnable参数构造新的Thread对象  
- public Thread( );
- public Thread(Runnable target);
- public Thread(String name);
- public Thread(Runnable target, String name);
- public Thread(ThreadGroup group, Runnable target);
- public Thread(ThreadGroup group, String name);
- public Thread(ThreadGroup group, Runnable target, String name);
- public Thread(ThreadGroup group, Runnable target, String name, long stackSize);
```
public static void main(String[] args) {
        Runnable runnable = new MyRunnable();
        Thread thread = new Thread(runnable);
        thread.start();
        System.out.println("运行结束");
    }
}
class MyRunnable implements Runnable {
    public void run () {
        System.out.println("运行中");
    }
}
```

#### 实例4
多个线程同时访问，可能会出现非线程安全问题。
非线程安全问题是指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、
值不同步的情况，进而影响程序的执行过程。
```
public static void main(String[] args) {
    MyThread myThread = new MyThread();
    Thread a = new Thread(myThread, "A");
    Thread b = new Thread(myThread, "B");
    Thread c = new Thread(myThread, "C");
    Thread d = new Thread(myThread, "D");
    Thread e = new Thread(myThread, "E");
    a.start();
    b.start();
    c.start();
    d.start();
    e.start();
}
class MyThread extends Thread {
    private int count = 5;
    public void run () {
        super.run();
        count--;
        System.out.println(this.currentThread().getName()+"--"+count);
    }
}
 ```
 
 #### 额外注意
 ```
 count--, System.out.println(this.currentThread().getName()+"--"+count);与  
 System.out.println(this.currentThread().getName()+"--"+count--);  
 二者均存在非线程安全问题，虽然在println()方法内部是同步的，但是i--的操作却是在进入println()之前发生的。
 ```
