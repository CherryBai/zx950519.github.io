---
layout:     post
title:      LeetCode解题总结
subtitle:   个人向解题思路汇总(Java实现)
date:       2018-04-22
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - LeetCode
    - Java
    - 总结
---

>不积跬步 无以至千里

## 22. 括号生成
```
class Solution {   
    public List<String> ans = new ArrayList();    
    public List<String> generateParenthesis(int n) {   
        if(n==1){
            ans.add("()");
            return ans;
        }
        String path = "";
        Func(n, n, path);  
        return ans;
    }
    public void Func(int left, int right, String path){        
        if(left==0&&right==0){
            ans.add(path);
            return;
        }
        if(left!=0)
            Func(left-1,right,path+"(");
        if(right!=0&&left<right)
            Func(left,right-1,path+")");
    }
}
```

## 26. 从排序数组中删除重复项
```
class Solution {
    public int removeDuplicates(int[] nums) {
       
        int count = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[count] != nums[i]){
                nums[++count] = nums[i];
            }
        }
        
        return count+1;
    
    }
}
```
## 48. 旋转图像

```
class Solution {
    public void rotate(int[][] matrix) {
        // 先转置
        for(int i=0; i<matrix.length; i++) {
            for(int j=i; j<matrix.length; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = tmp;
            }
        }
        // 交换列
        for(int i=0; i<matrix.length/2; i++) {
            for(int j=0; j<matrix.length; j++) {
                int tmp = matrix[j][i];
                matrix[j][i] = matrix[j][matrix.length-1-i];
                matrix[j][matrix.length-1-i] = tmp;
            }
        }
    }
}
```

## Pow(x, n)

```
class Solution {
    public double myPow(double x, int n) {
        
        // 暴力法
        //return Math.pow(x, n);
        
        if(n==0)
            return 1.0;
        if(x==0)
            return 0.0;
        
        // 迭代法
        // double res = 1.0;
        // double base = x;
        // int tmp = n;
        // while (tmp!=0) {
        //     if(tmp%2!=0)
        //         res *= base;
        //     base *= base;
        //     tmp /= 2;
        // }
        // return n <0 ? 1.0 / res : res;
        
        // 递归法
        if(n==0)
            return 1;
        double half = myPow(x, n/2);
        if(n%2==0)
            return half * half;
        else if(n>0)
            return half * half * x;
        else
            return half * half / x;
        
    }
}
```

## 62. 不同路径

```
import java.util.*;

class Solution {
    public int uniquePaths(int m, int n) {
        if(m==1||n==1) 
            return 1;
        // 动态规划法求解
        // int[][] data = new int[m+1][n+1];
        // for(int i=1; i<=m; i++) {
        //     for(int j=1; j<=n; j++) {
        //         if(i==1&&j==1) {
        //             data[i][j] = 1;
        //             continue;
        //         }
        //         data[i][j] = data[i-1][j] + data[i][j-1];
        //     }
        // }
        // return data[m][n];
        
        // 数学方法解 求C(small-1, m+n-2)的组合种类
        double num = 1, denom = 1;
        int small = m > n ? n : m;
        for (int i = 1; i <= small - 1; ++i) {
            num *= m + n - 1 - i;
            denom *= i;
        }
        return (int)(num / denom);
        
    }
    
}
```

## 69. Sqrt(x)
```
class Solution {
    public int mySqrt(int x) {
        double pre = 0;  
        double cur = x;             
        while(Math.abs(cur - pre) > 0.000001){  
            pre = cur;  
            cur = (pre/2 + x/(2*pre));  
        }  
        return (int)cur;  
        
        // double begin = 0;  
        // double end = x;  
        // double result = 1;  
        // double mid = 1;  
        // while(Math.abs(result-x) > 0.000001){  
        //     mid = (begin+end)/2;  
        //     result = mid*mid;  
        //     if(result > x)    
        //         end = mid;  
        //     else begin = mid;  
        // }  
        // return (int)mid;  
    }
}
```

## 94. Binary Tree Inorder Traversal
```
import java.util.List;
import java.util.ArrayList;
class Solution {
    private List<Integer> l = null;
    public List<Integer> inorderTraversal(TreeNode root) {
        l = new ArrayList();
        if(root==null)
            return new ArrayList();
        visit(root);
        return l;
    }
    public void visit(TreeNode root){
        if(root==null)
            return;
        visit(root.left);
        l.add(root.val);
        visit(root.right);
    }
}
```

## 100. Same Tree
``` javascript
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null)
            return true;
        else if(p==null&&q!=null)
            return false;
        else if(p!=null&&q==null)
            return false;
        else{
            if(p.val!=q.val)
                return false;
            else
                return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
        }          
    }
}
```

## 104. Maximum Depth of Binary Tree
```
class Solution {
    public int maxDepth(TreeNode root) {
        int depth = 0;
        if(root!=null){
            int l = maxDepth(root.left);
            int r = maxDepth(root.right);
            depth = l>r?l+1:r+1;
        }
        return depth;
    }
}
```

## 107. Binary Tree Level Order Traversal II
```
import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections; 
class Solution {
    List<List<Integer>> ans = null;
    List<Integer> tmp = null;
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        ans = new ArrayList();
        tmp = new ArrayList();
        if(root==null)
            return ans;
        visit(root);
        reverse(ans);
        return ans;
    }
    public void visit(TreeNode root){
        Queue<TreeNode> q = new LinkedList();
        Queue<TreeNode> tq = new LinkedList();
        if(root==null)
            return;
        q.offer(root);
        while(q.peek()!=null){
            TreeNode tn = q.poll();
            tmp.add(tn.val);
            if(tn.left!=null)
                tq.offer(tn.left);
            if(tn.right!=null)
                tq.offer(tn.right);
            if(q.peek()==null){
                ans.add(tmp);
                tmp = new ArrayList();
                q = tq;
                tq = new LinkedList();
            }
        }
    }
    public void reverse(List<List<Integer>> lps){
        Collections.reverse(lps);
    }
}
```

## 111. Minimum Depth of Binary Tree
```
class Solution {
    public int minDepth(TreeNode root) {
        //原子操作
        if(root==null)
            return 0;
        if(root.left==null&&root.right==null)
            return 1;
        
        if(root.left==null)
            return minDepth(root.right)+1;
        else if(root.right==null)
            return minDepth(root.left)+1;
        else
            return Math.min(minDepth(root.left),minDepth(root.right))+1;
    }
}
```
## 112. Path Sum
```
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        
        if(root==null)
            return false;
        else if(root.left==null&&root.right==null&&sum==root.val){
                return true;
        }
        else{
            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);
        }
        
    }
}
```

## 118. 帕斯卡三角形
```
class Solution {
    public List<List<Integer>> generate(int numRows) {     
        if(numRows==0){
            List<List<Integer>> ans = new ArrayList();
            return ans;
        }                   
        if(numRows==1){
            List<Integer> list = new ArrayList();
            list.add(1);
            List<List<Integer>> ans = new ArrayList();
            ans.add(list);
            return ans;
        }       
        List<List<Integer>> ans = new ArrayList();
        for(int i=0;i<numRows;i++){
            List<Integer> list = new ArrayList();
            for(int j=0;j<i+1;j++){
                
                if(j==0)
                    list.add(1);
                else if(j==i){
                    list.add(1);
                }
                else{
                    list.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j));
                }
            }  
            ans.add(list);
        }          
        return ans;
    }
}
```

## 136. 只出现一次的数字
```
class Solution {
    public int singleNumber(int[] nums) {
        if(nums.length==1)
            return nums[0];
        Map<Integer,Integer> mmp = new HashMap();
        for(int i=0;i<nums.length;i++){
            mmp.put(nums[i],mmp.getOrDefault(nums[i],0)+1);
        }
        for(Map.Entry<Integer,Integer> entry:mmp.entrySet()){
            if(entry.getValue()==1)
                return entry.getKey();
        }
        return 0;
        
        int tmp = 0;
        for(int i=0;i<nums.length;i++)
            tmp ^= nums[i];
        return tmp;
    }
}
```

## 144. Binary Tree Preorder Traversal
```
import java.util.List;
import java.util.ArrayList;
class Solution {
    private List<Integer> l = null;
    public List<Integer> preorderTraversal(TreeNode root) {
        l = new ArrayList();
        if(root==null)
            return new ArrayList();
        visit(root);
        return l;
    }
    public void visit(TreeNode root){
        if(root==null)
            return;
        l.add(root.val);
        visit(root.left);
        visit(root.right);
    }
}
```

## 145. Binary Tree Postorder Traversal
```
import java.util.List;
import java.util.ArrayList;
class Solution {
    private List<Integer> l = null;
    public List<Integer> postorderTraversal(TreeNode root) {
        l = new ArrayList();
        if(root==null)
            return l;
        visit(root);
        return l;
    }
    public void visit(TreeNode root){
        if(root==null)
            return;
        visit(root.left);
        visit(root.right);
        l.add(root.val);
    }
}
```

## 162. 寻找峰值
```
class Solution {
    public int findPeakElement(int[] nums) {
        int left=0, right=nums.length-1;
        while(left<right){
            int mid = (left+right)/2;
            if(nums[mid]<nums[mid+1])
                left=mid+1;
            else
                right=mid;
        }
        return left;
    }
}
```

## 167. Two Sum II - Input array is sorted
```
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int index1 = 0;
        int index2 = 0;
        out:
        for(int i=0;i<numbers.length;i++){
            for(int j=i+1;j<numbers.length;j++){
                
                if(numbers[i] + numbers[j] > target){
                    break;
                }
                if(numbers[i] + numbers[j] == target){
                    index1 = i;
                    index2 = j;
                    break out;
                }
            }
        }
        int[] ans = new int[2];
        ans[0] = index1+1;
        ans[1] = index2+1;
        return ans;
    }
}
```

## 169. Majority Element
```
import java.util.Map;
import java.util.HashMap;
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer,Integer> mmp = new HashMap();       
        for (int i=0;i<nums.length;i++){
            int ans = mmp.getOrDefault(nums[i], 0);
            mmp.put(nums[i], ans+1);
        }
        int max = 0;
        int index = 0;
        for (Map.Entry<Integer, Integer> entry : mmp.entrySet()) { 
            if(entry.getValue()>max){
                index = entry.getKey();
                max = entry.getValue();
            }       
        }
        return index;
    }
}
```

## 172*. 阶乘后的零
```java
class Solution {
    public int trailingZeroes(int n) {
        //考虑25！,25可以分解为5*5,不能简单返回n/5，计算n/5， 还要计算n/5/5, n/5/5/5, n/5/5/5/5, ..., n/5/5/5,,,/5直到商为0。
        if(n==0)
            return 0;
        int sum=0;
        while(n>0){
            sum += n/5;
            n /= 5;
        }
        return sum;
    }
}
```

## 173. Binary Search Tree Iterator
```
import java.util.Stack;
public class BSTIterator {
    
    Stack<TreeNode> s = null;
    
    public BSTIterator(TreeNode root) {
        s = new Stack();
        if (root == null){
            return ;
        }
        TreeNode node = root;
        while(node!=null){
            s.push(node);
            node = node.left;
        }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        if(s.isEmpty())
            return false;
        else
            return true;
    }

    /** @return the next smallest number */
    public int next() {
        TreeNode node = s.pop();
        int ans = node.val;
        if(node.right!=null){
            node = node.right;
            while(node!=null){
                s.push(node);
                node = node.left;
            }
        }
        return ans;
    }
    
}
```

## 202. Happy Number
```
class Solution {
    public boolean isHappy(int n) {
        if(n<10){
            if(n==1||n==7)
                return true;
        }
        
        int nn = n;
        while(nn>=10){
            int sum = 0;
            while(nn>0){
                sum += (nn%10)*(nn%10);
                nn/=10;
            }
            nn = sum;
        }
        if(nn==1||nn==7)
            return true;
        else
            return false;
        
    }
}
```

## 204. Count Primes
```
class Solution {
    public int countPrimes(int n) {
        
        if(n<=2)
            return 0;
        if(n==3)
            return 1;
        if(n==4)
            return 2;
        
        int[] ai = new int[n+1];
        for(int i=2;i<n;i++)
            ai[i] = 1;
        ai[0]=0;
        ai[1]=0;
        int max = (int)Math.sqrt(n);
        for(int i=2;i<=max;i++){
            if(ai[i]==0)
                continue;
            for(int j=i*i;j<n;j+=i)
                ai[j]=0;
        }
        
        int sum=0;
        for(int i=2;i<n;i++)
            if(ai[i]==1)
                sum++;
        return sum;
    }
}
```

## 217. 存在重复
```
class Solution {
    public boolean containsDuplicate(int[] nums) {
        if(nums.length==0)
            return false;
        Map<Integer,Boolean> mmp = new HashMap();
        for(int i=0;i<nums.length;i++){
            if(mmp.getOrDefault(nums[i],false)==false)
                mmp.put(nums[i],true);
            else
                return true;
        }
        
        return false;
    }
}
```

## 226. Invert Binary Tree
```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null)
            return null;
        function(root);
        return root;
    }
    public void function(TreeNode root){
        if(root==null)
            return;
        else{
            TreeNode tmp = root.left;
            root.left = root.right;
            root.right = tmp;
            function(root.left);
            function(root.right);
        }
    }
}
```

## 228. 汇总区间
```
class Solution {
    public List<String> summaryRanges(int[] nums) {
        if(nums.length==0)
            return new ArrayList();
        List<String> ans = new ArrayList();
        if(nums.length==1){
            ans.add((nums[0])+"");
            return ans;
        }
            
        int start = 0, end = 0;
        
        for(int i=1;i<nums.length;i++){
            if(nums[i]-nums[i-1]!=1){
                //区间长度为0
                if(start==i-1){
                    ans.add(""+nums[start]);
                }
                //区间长度大于0
                else{
                    ans.add(nums[start]+"->"+nums[i-1]);
                }
                start=i;
            }
            else{
                continue;
            }
        }
        if(nums[nums.length-1]-nums[nums.length-2]==1)
            ans.add(nums[start]+"->"+nums[nums.length-1]);
        else
            ans.add(nums[nums.length-1]+"");
        
        return ans;
    }
}
```

## 229. 求众数 II
```
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        
        if(nums.length==0)
            return new ArrayList();
        
        List<Integer> lpl = new ArrayList();
        Map<Integer,Integer> mmp = new HashMap();
        for(int i=0;i<nums.length;i++){
            mmp.put(nums[i], mmp.getOrDefault(nums[i], 0)+1);
        }
        for(Map.Entry<Integer, Integer> entry:mmp.entrySet()){
            if(entry.getValue()>nums.length/3)
                lpl.add(entry.getKey());
        }
        return lpl;
    }
}
```
## 230. Kth Smallest Element in a BST
```
class Solution {
    private int index = 0;
    private int ans = 0;
    public int kthSmallest(TreeNode root, int k) {
        visit(root,k);
        return ans;
    }
    
    public void visit(TreeNode root,int k){
        if(root==null)
            return;
        visit(root.left,k);
        ++index;
        if(index>k)
            return;
        if(index==k){
            ans = root.val;
            return;
        }    
        visit(root.right,k);
    }
}
```

## 231. Power of Two
```
class Solution {
    public boolean isPowerOfTwo(int n) {
        // while(n>0&&n%2==0)
        //     n/=2;
        // if(n==1)
        //     return true;
        // else
        //     return false;
        return n > 0 && ((n & (n - 1)) == 0 );  
    }
    
}
```

## 257. Binary Tree Paths
```
import java.util.List;
import java.util.Vector;
class Solution {
    private List<String> ls;
    public List<String> binaryTreePaths(TreeNode root) {
        if(root==null)
            return new ArrayList();
        ls = new ArrayList();    
        DFS(ls,root,root.val+"");
        return ls;
    }
    
    public void DFS(List<String> vec,TreeNode root,String str){
        if(root.left==null&&root.right==null){
            vec.add(str);
            return;
        }
        if(root.left!=null){
            DFS(vec,root.left,str+"->"+root.left.val);
        }
        if(root.right!=null){
            DFS(vec,root.right,str+"->"+root.right.val);
        }
    }
    
}
```

## 258. Add Digits
```
class Solution {
    public int addDigits(int num) {
        if(num==0)
            return 0;
        if(num==1)
            return 1;
        if(num<10&&num>0)
            return num;
        int ans = getSum(num);
        if(ans<10&&ans>0)
            return ans;
        else
            return addDigits(ans);
    }
    public int getSum(int number){
        int ans = 0;
        while(number > 0){
            ans += number % 10;
            number /= 10;
        }
        return ans;
    }
}
```

## 263. Ugly Number
```
class Solution {
    public boolean isUgly(int num) {
        while(num>=2){
            if(num%2==0)
                num /= 2;
            else if(num%3==0)
                num /= 3;
            else if(num%5==0)
                num /=5;
            else
                return false;
        }
        if(num==1)
            return true;
        else
            return false;
    }   
}
```



## 264*. Ugly Number II
```java
import java.util.List;
class Solution {
    public int nthUglyNumber(int n) {      
       List<Integer> l = new ArrayList();
       l.add(1);
       int r2 = 0, r3 = 0, r5 = 0;
       while(l.size() < n){
            int m2 = l.get(r2)*2;
            int m3 = l.get(r3)*3;
            int m5 = l.get(r5)*5;
            int min = Math.min(m2,Math.min(m3,m5));
            l.add(min);
            if(m2==min)
                r2++;
            if(m3==min)
                r3++;
            if(m5==min)
                r5++;
       }
       return l.get(l.size()-1);            
    }
}
```

## 268. 缺失数字
```
class Solution {
    public int missingNumber(int[] nums) {
        boolean[] ans = new boolean[nums.length+1];
        for(int i=0;i<nums.length;i++)
            ans[nums[i]]=true;
        for(int i=0;i<ans.length;i++)
            if(ans[i]==false)
                return i;
        return -1;
    }
}
```

## 283. Move Zeroes
```
class Solution {
    public void moveZeroes(int[] nums) {
        if(nums.length==0)
            return;
        int zero = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==0){
                zero++;
            }
            else{
                nums[i-zero] = nums[i];
            }
        }
        for(int i=nums.length-zero;i<nums.length;i++)
            nums[i] = 0;
    }
}
```

## 287. 寻找重复数
```
class Solution {
    public int findDuplicate(int[] nums) {
        if(nums.length==0)
            return 0;
        Map<Integer,Integer> mmp = new HashMap();
        for(int i=0;i<nums.length;i++)
            mmp.put(nums[i],mmp.getOrDefault(nums[i],0)+1);
        for(Map.Entry<Integer,Integer> entry:mmp.entrySet())
            if(entry.getValue()>1)
                return entry.getKey();
        return nums.length-1;
    }
}
```

## 326. Power of Three
```
class Solution {
    public boolean isPowerOfThree(int n) {
        while(n>0&&n%3==0){
            n = n/3;
        }
        if(n==1)
            return true;
        else
            return false;
    }
    
    public boolean function1(int n){
        return n>0?!(1162261467 % n):0;
    }
    
    public boolean function2(int n){
        double res = log10(n) / log10(3);  //有精度问题，不要用以指数2.718为低的log函数  
        return (res - int(res) == 0) ? true : false;  
    }
    
}
```

## 343. Integer Break
```
class Solution {
    public int integerBreak(int n) {
        int[] ans = new int[59];
        ans[1] = 1;
        ans[2] = 1;
        for(int i=3;i<=n;i++){
            ans[i] = -1;
            for(int j=1;j<i;j++){
                ans[i] = Math.max(j*ans[i-j],Math.max(j*(i-j),ans[i]));
            }
        }
        return integerBreak2(n);
    }
    public int integerBreak2(int n){      
        if(n==2)
            return 1;
        else if(n==3)
            return 2;
        else if(n%3==0)
            return (int)Math.pow(3,n/3);
        else if(n%3==1)
            return 2*2*(int)Math.pow(3,(n-3-1)/3);
        else
            return 2*(int)Math.pow(3,(n)/3);
        
    }
}
```

## 378. 有序矩阵中第K小的元素
```
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        List<Integer> ipz = new ArrayList();
        int index = 0;
        for(int i=0;i<matrix.length;i++)
            for(int j=0;j<matrix.length;j++)
                // ipz[index] = matrix[i][j];
                ipz.add(matrix[i][j]);
        Collections.sort(ipz);
        return ipz.get(k-1);
    }
}
```

## 389. 找不同
```
class Solution {
    public char findTheDifference(String s, String t) {
        
        Map<Character, Integer> hs = new HashMap();
        // Map<String, Integer> hsr = new HashMap();
        
        for(int i=0;i<t.length();i++){
            if(i<t.length()-1){
                hs.put(s.charAt(i),hs.getOrDefault(s.charAt(i),0)+1);
            }
            hs.put(t.charAt(i),hs.getOrDefault(t.charAt(i),0)-1);
        }
        
        for(Map.Entry<Character, Integer> entry:hs.entrySet()){
            if(entry.getValue()==-1)
                return entry.getKey();
        }
        
        return new String("z").charAt(0);
        
    }
}
```

## 404. Sum of Left Leaves
```
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        return visit(root,false);
    }
    
    public int visit(TreeNode root,Boolean isLeft){
        if(root==null)
            return 0;
        int sum = 0;
        if(root.left!=null||root.right!=null){
            
            sum += visit(root.left,true);
            sum += visit(root.right,false);
        }
        else if(isLeft){
            sum += root.val;
        }
        return sum;
    }
}
```

## 409. 最长回文串
```
class Solution {
    public int longestPalindrome(String s) {
        if(s.length()==0)
            return 0;
        Map<Character,Integer> mmp = new HashMap();
        for(int i=0;i<s.length();i++)
            mmp.put(s.charAt(i),mmp.getOrDefault(s.charAt(i),0)+1);
        int sum = 0;
        boolean hasOne = false;
        for(Map.Entry<Character,Integer> entry:mmp.entrySet())
            if(entry.getValue()==1)
                hasOne = true;
            else{
                if(entry.getValue()%2==0)
                    sum += entry.getValue();
                else{
                    sum += entry.getValue()-1;
                    hasOne = true;
                }               
            }
        if(hasOne==true)
            sum++;
        
        return sum;
    }
}
```

## 448. Find All Numbers Disappeared in an Array
```
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        //获取数组长度
        int n = nums.length;
        //剪枝
        if(n<1)
            return new ArrayList<>();
        //定义统计下标的数组
        int[] pick = new int[n+1];
        //置零
        for(int i=0;i<=n;i++)
            pick[i] = 0;
        //统计
        for(int i=0;i<n;i++)
            pick[nums[i]]++;
        //返回值
        List<Integer> li = new ArrayList<>();
        //统计
        for(int i=1;i<=n;i++){
            if(pick[i]<1)
                li.add(i);
        }
        return li;
    }
}
```

## 414.第三大的数

```
import java.util.*;
class Solution {
    public int thirdMax(int[] nums) {
        Map<Integer, Integer> map = new TreeMap<>();
        int sum = 0;
        int max = Integer.MIN_VALUE;
        for(int i=0; i<nums.length; i++) {
            if(map.getOrDefault(nums[i], 0) == 0) {
                sum++;
                if(nums[i] > max) 
                    max = nums[i];
                map.put(nums[i], 1);
            }
        }
        int tmp = 0;
        map = ((TreeMap) map).descendingMap();
        if(sum<3) 
            return max;
        else{
            int index = 0;
            for(Map.Entry<Integer, Integer> entry: map.entrySet()) {
                index++;
                if(index==3) {
                    tmp = entry.getKey();
                    break;
                }
            }
        }
        return tmp;
    }
}
```

## 442. 数组中重复的数据
```
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> lpl = new ArrayList();
        // Map<Integer, Integer> mmp = new HashMap();
        // for(int i=0;i<nums.length;i++){
        //     mmp.put(nums[i],mmp.getOrDefault(nums[i], 0)+1);
        // }
        // for(Map.Entry<Integer, Integer> entry:mmp.entrySet()){
        //     if(entry.getValue()==2)
        //         lpl.add(entry.getKey());
        // }
        // return lpl;
        
        for(int i=0;i<nums.length;i++){
            int index = Math.abs(nums[i])-1;
            if(nums[index]<0)
                lpl.add(Math.abs(index+1));
            nums[index] = -nums[index];
        }
        return lpl;
    }
}
```

## 453. Minimum Moves to Equal Array Elements
```
class Solution {
    public int minMoves(int[] nums) {
        int index = getMinIndex(nums);
        int sum = 0;
        for(int i=0;i<nums.length;i++)
            sum += nums[i]-nums[index];
        return sum;
    }
    public int getMinIndex(int[] nums){
        int index = 0,min = nums[0];
        for(int i=0;i<nums.length;i++)
            if(nums[i]<min){
                min = nums[i];
                index = i;
            }
        return index;
    }
}
```

## 463. Island Perimeter
```
class Solution {
    public int islandPerimeter(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int sum = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j] == 1){
                    if(i==0||grid[i-1][j]==0)
                        sum++;
                    if(i==n-1||grid[i+1][j]==0)
                        sum++;
                    if(j==0||grid[i][j-1]==0)
                        sum++;
                    if(j==m-1||grid[i][j+1]==0)
                        sum++;
                    
                }
            }
        }
        return sum;
    }
}
```

## 485. 最大连续1的个数
```
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0,cur = 0;
        if(nums.length==0)
            return 0;
        
        for(int i=0;i<nums.length;i++){
            if(nums[i]==0){
                if(cur>max)
                    max = cur;
                cur = 0;
            }
            else
                cur++;
        }
        if(cur > max)
            max = cur;
        
        return max;
    }
}
```

## 501. Find Mode in Binary Search Tree
```
import java.util.Map; 
import java.util.List;
class Solution {
    
    private Map<Integer,Integer> mmp;
    private int max = 0;
    
    public int[] findMode(TreeNode root) {
        
        if(root==null)
            return new int[0];
        mmp = new HashMap<>();
        
        visit(root);
        
        List<Integer> list = new LinkedList<>();
        for (int key : mmp.keySet()) {  
            if (mmp.get(key) == max)  
                list.add(key);  
        }  
        
        int[] res = new int[list.size()];  
        for (int i = 0; i < res.length; i++)  
            res[i] = list.get(i);  
        
        return res;  
        
    }
    
    
    public void visit(TreeNode root){
        if(root.left!=null)
            visit(root.left);
        mmp.put(root.val,
                mmp.getOrDefault(root.val, 0)+1);
        max = Math.max(max,mmp.get(root.val));
        if(root.right!=null)
            visit(root.right);
    }
}
```

## 508. Most Frequent Subtree Sum
```
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;
class Solution {
    
    private Map<Integer,Integer> map = new HashMap();
    
    public int[] findFrequentTreeSum(TreeNode root) {
        if(root==null)
            return new int[0];
        change(root);
       
        visit(root);
        int max = -1;
        for (int key : map.keySet()) {
            // System.out.println("map.get(" + key + ") = " + map.get(key));
            if(max < map.get(key))
                max = map.get(key);
        }
        
        Vector<Integer> vec = new Vector();
        for (int key : map.keySet()) {
            if(map.get(key)==max)
                vec.add(key);
        }
        
        int[] ans = new int[vec.size()];
        for(int i=0;i<vec.size();i++)
            ans[i] = vec.get(i);
        return ans;
    }
    
    public void change(TreeNode root){
        if(root==null)
            return;
        change(root.left);
        
        change(root.right);
        int sum = 0;
        if(root.left!=null)
            sum += root.left.val;
        if(root.right!=null)
            sum += root.right.val;
        sum += root.val;
        root.val = sum;
    }
    public void visit(TreeNode root){
        if(root==null)
            return;
        int m = map.getOrDefault(root.val,0);
        m++;
        map.put(root.val,m);
        visit(root.left);
        visit(root.right);
    }
}
```

## 515. Find Largest Value in Each Tree Row
```
// import java.util.Queue;
// import java.util.LinkedList;
import java.util.*;
class Solution {
    List<Integer> l = null;
    public List<Integer> largestValues(TreeNode root) {
        l = new ArrayList();
        if(root==null)
            return l;
        Queue<TreeNode> q = new LinkedList();
        q.offer(root);
        while(!q.isEmpty()){
            int max = Integer.MIN_VALUE;
            int num = q.size();
            for(int i=0;i<num;i++){
                TreeNode tn = q.poll();
                max = Math.max(max, tn.val);
                if(tn.left!=null)
                    q.offer(tn.left);
                if(tn.right!=null)
                    q.offer(tn.right);
            }
            l.add(max);
        }
        return l;
    }
}
```

## 561. Array Partition I
```
import java.util.Arrays;
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int sum = 0;
        for(int i=0;i < nums.length;i+=2){
            sum += nums[i];
        }
        return sum;
    }
}
```

## 566. 重塑矩阵
```
class Solution {
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        if(r*c != nums.length*nums[0].length)
            return nums;
        List<Integer> tmp = new ArrayList();
        for(int i=0;i<nums.length;i++)
            for(int j=0;j<nums[i].length;j++){
                tmp.add(nums[i][j]);
            }
        int[][] ans = new int[r][c];
        int first = 0, sencond = 0;
        for( int i = 0 ; i < tmp.size() ; i++) {
            if(i%c==0)
                sencond=0;
            ans[i/c][sencond] = tmp.get(i);
            sencond++;
        }
        return ans;
        
    }
}
```

## 593. Valid Square
```
class Solution {
    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {
        
        boolean b1 = judegSolo(p1,p2,p3,p4);
        boolean b2 = judegSolo(p2,p3,p4,p1);
        boolean b3 = judegSolo(p3,p4,p1,p2);
        boolean b4 = judegSolo(p4,p1,p2,p3);
        return b1&&b2&&b3&&b4;
    }
    public boolean judegSolo(int[] p1, int[] p2, int[] p3, int[] p4){
        double p1_p2 = (p2[0]-p1[0])*(p2[0]-p1[0])+(p2[1]-p1[1])*(p2[1]-p1[1]);
        double p1_p3 = (p3[0]-p1[0])*(p3[0]-p1[0])+(p3[1]-p1[1])*(p3[1]-p1[1]);
        double p1_p4 = (p4[0]-p1[0])*(p4[0]-p1[0])+(p4[1]-p1[1])*(p4[1]-p1[1]);
        if(p1_p2==0||p1_p3==0||p1_p4==0)
            return false;
        if(p1_p2==p1_p3&&p1_p2+p1_p3==p1_p4)
            return true;
        if(p1_p2==p1_p4&&p1_p2+p1_p4==p1_p3)
            return true;
        if(p1_p3==p1_p4&&p1_p3+p1_p4==p1_p2)
            return true;
        return false;
    }
}
```

## 617.Merge Two Binary Trees
```
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if(t1==null&&t2==null){
            return null; 
        }
        if(t1==null)
            return t2;
        else if(t2==null)
            return t1;
        else{
            t1.val += t2.val;
            t1.left = mergeTrees(t1.left,t2.left);
            t1.right = mergeTrees(t1.right,t2.right);
        }
        return t1;
    }
}
```

## 623
```
import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
class Solution {
    Queue<TreeNode> q = null;
    public TreeNode addOneRow(TreeNode root, int v, int d) {
        q = new LinkedList();
        Queue<TreeNode> tmp = new LinkedList();
        int layer = 1;
        while(q.peek()!=null){
            //弹出队首元素
            TreeNode tn = q.poll();
            if(tn.left!=null)
                tmp.offer(tn.left);
            if(tn.right!=null)
                tmp.offer(tn.right);
            if(layer+1==d){
                TreeNode t1 = new TreeNode(v);
                TreeNode t2 = new TreeNode(v);
                t1.left = tn.left;
                tn.left = t1;
                t1.right = null;
                t2.right = tn.right;
                tn.right = t2;
                t1.left = null;
            }
            if(q.peek()==null){
                layer++;
                q = tmp;
                tmp = new LinkedList();
            }
        }
        return root;
    }
}
```

## 628. Maximum Product of Three Numbers
```
import java.util.Vector;
class Solution {
    public int maximumProduct(int[] nums) {
        if(nums.length==3)
            return nums[0]*nums[1]*nums[2];
        // sort(nums,0,nums.length-1);
        Vector<Integer> v = new Vector();
        for(int i=0;i<nums.length;i++)
            v.add(nums[i]);
        Collections.sort(v,Collections.reverseOrder());
        int ans = v.get(0)*v.get(1)*v.get(2);
        if(ans < v.get(v.size()-1)*v.get(0)*v.get(1))
            ans = v.get(v.size()-1)*v.get(0)*v.get(1);
        if(ans < v.get(v.size()-2)*v.get(v.size()-1)*v.get(0))
            ans = v.get(v.size()-2)*v.get(v.size()-1)*v.get(0);
        if(ans < v.get(v.size()-3)*v.get(v.size()-2)*v.get(v.size()-1))
            ans = v.get(v.size()-3)*v.get(v.size()-2)*v.get(v.size()-1);
        return ans;
    }
}
```

## 637. Average of Levels in Binary Tree
```
import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
class Solution {
    //原始队列
    private Queue<TreeNode> q = null;
    //原始数组
    private List<Double> l = null;
    public List<Double> averageOfLevels(TreeNode root) {
        //剪枝
        if(root.left==null&&root.right==null){
            l = new ArrayList<Double>();
            l.add(new Double(root.val));
            return l;
        }
        //初始化    
        l = new ArrayList();
        q = new LinkedList<TreeNode>();
        //根节点入队
        q.offer(root);
        //暂存子节点的队列
        Queue<TreeNode> tmp = new LinkedList<TreeNode>();
        //中间变量
        double sum = 0,tick = 0;
        while(q.peek()!=null){
            //弹出队首元素
            TreeNode tn = q.poll();
            sum += tn.val;
            tick++;
            //左右子节点入队
            if(tn.left!=null)
                tmp.offer(tn.left);
            if(tn.right!=null)
                tmp.offer(tn.right);
            //判断是否到达该层尽头
            if(q.peek()==null){
                l.add(new Double(sum/tick));
                sum = 0;
                tick = 0;
                q = tmp;
                tmp = new LinkedList<TreeNode>();
            }
        }
        return l;
    }
}
```

## 653. Two Sum IV - Input is a BST
```
import java.util.Vector;
class Solution {
    private Vector<Integer> vec;
    public boolean findTarget(TreeNode root, int k) {
        if(root==null)
            return false;
        vec = new Vector();
        visit(root);
        if(vec.size()<2)
            return false;
        
        for(int i=0;i<vec.size();i++)
            for(int j=i+1;j<vec.size();j++){
                int tmp = vec.get(i)+vec.get(j);
                if(tmp==k)
                    return true;
            }
        return false;
    }
    
    public void visit(TreeNode root){
        if(root==null)
            return;
        visit(root.left);
        vec.add(root.val);
        visit(root.right);
    }
}
```

## 654. Maximum Binary Tree
```
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if(nums.length==0)
            return null;
        return visit(nums,0,nums.length-1);
    }
    public TreeNode visit(int[] nums,int left,int right){
        if(left>right)
            return null;
        int index = max(nums, left, right);
        TreeNode root = new TreeNode(nums[index]);
        root.left = visit(nums,left,index-1);
        root.right = visit(nums,index+1,right);
        return root;
    }
    
    public int max(int[] nums, int left, int right) {
        int max = Integer.MIN_VALUE, index = 0;
        for (int i=left; i<=right; i++) {
            if (max < nums[i]) {
                index = i;
                max= nums[i];
            }
        }
        return index;
    }
}
```

## 665*. 非递减数列
```java
class Solution {
    public boolean checkPossibility(int[] nums) {
        if(nums.length==0||nums.length==1)
            return true;
        int cnt = 0;
        for(int i=1;i<nums.length&&cnt<=1;i++){
            if(nums[i-1]>nums[i]){
                cnt++;
                if(i-2<0||nums[i-2]<=nums[i])
                    nums[i-1] = nums[i];
                else
                    nums[i] = nums[i-1];
            }
        }       
        return cnt<=1;
    }    
}
```

## 669. Trim a Binary Search Tree
```
class Solution {
    public TreeNode trimBST(TreeNode root, int L, int R) {
        if(root==null)
            return root;
        if(root.val<L){
            return trimBST(root.right,L,R);
        }
        else if(root.val>R){
            return trimBST(root.left,L,R);
        }
        else{
            root.left = trimBST(root.left,L,R);
            root.right = trimBST(root.right,L,R);
            return root;
        }
    }
}
```

## 728. Self Dividing Numbers
```
class Solution {
    List<Integer> lpl = null;
    public List<Integer> selfDividingNumbers(int left, int right) {
        lpl = new ArrayList();
        for(int i=left;i<=right;i++){
            int tmp = i;
            while(tmp!=0&&tmp%10!=0){
                if(i%(tmp%10)!=0)
                    break;
                tmp /= 10;
            }
            if(tmp==0)
                lpl.add(i);
        }
        return lpl;
    }
}
```

## 747. Largest Number At Least Twice of Others
```
class Solution {
    public int dominantIndex(int[] nums) {
        int max = nums[0];
        int index = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]>max){
                max = nums[i];
                index = i;
            }
        }
        for(int i=0;i<nums.length;i++){
            if(max==nums[i])
                continue;
            if(max >= nums[i] * 2){
                continue;
            }
            else{
                return -1;
            }
        }
        return index;
    }
}
```


