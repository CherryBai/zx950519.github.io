---
layout:     post
title:      LeetCode解题总结
subtitle:   个人向解题思路汇总(Java实现)
date:       2018-04-22
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - LeetCode
    - Java
    - 总结
---

>不积跬步 无以至千里

## 100. Same Tree
``` javascript
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null)
            return true;
        else if(p==null&&q!=null)
            return false;
        else if(p!=null&&q==null)
            return false;
        else{
            if(p.val!=q.val)
                return false;
            else
                return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
        }          
    }
}
```
## 104. Maximum Depth of Binary Tree
```
class Solution {
    public int maxDepth(TreeNode root) {
        int depth = 0;
        if(root!=null){
            int l = maxDepth(root.left);
            int r = maxDepth(root.right);
            depth = l>r?l+1:r+1;
        }
        return depth;
    }
}
```

## 172*. 阶乘后的零
```java
class Solution {
    public int trailingZeroes(int n) {
        //考虑25！,25可以分解为5*5,不能简单返回n/5，计算n/5， 还要计算n/5/5, n/5/5/5, n/5/5/5/5, ..., n/5/5/5,,,/5直到商为0。
        if(n==0)
            return 0;
        int sum=0;
        while(n>0){
            sum += n/5;
            n /= 5;
        }
        return sum;
    }
}
```

## 264*. Ugly Number II
```java
import java.util.List;
class Solution {
    public int nthUglyNumber(int n) {      
       List<Integer> l = new ArrayList();
       l.add(1);
       int r2 = 0, r3 = 0, r5 = 0;
       while(l.size() < n){
            int m2 = l.get(r2)*2;
            int m3 = l.get(r3)*3;
            int m5 = l.get(r5)*5;
            int min = Math.min(m2,Math.min(m3,m5));
            l.add(min);
            if(m2==min)
                r2++;
            if(m3==min)
                r3++;
            if(m5==min)
                r5++;
       }
       return l.get(l.size()-1);            
    }
}
```

## 665*. 非递减数列
```java
class Solution {
    public boolean checkPossibility(int[] nums) {
        if(nums.length==0||nums.length==1)
            return true;
        int cnt = 0;
        for(int i=1;i<nums.length&&cnt<=1;i++){
            if(nums[i-1]>nums[i]){
                cnt++;
                if(i-2<0||nums[i-2]<=nums[i])
                    nums[i-1] = nums[i];
                else
                    nums[i] = nums[i-1];
            }
        }       
        return cnt<=1;
    }    
}
```


