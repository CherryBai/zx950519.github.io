---
layout:     post
title:      LeetCode解题总结
subtitle:   个人向解题思路汇总(Java实现)
date:       2018-04-22
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - LeetCode
    - Java
    - 总结
---

>不积跬步 无以至千里

## 100. Same Tree
``` javascript
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null)
            return true;
        else if(p==null&&q!=null)
            return false;
        else if(p!=null&&q==null)
            return false;
        else{
            if(p.val!=q.val)
                return false;
            else
                return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
        }          
    }
}
```
## 104. Maximum Depth of Binary Tree
```
class Solution {
    public int maxDepth(TreeNode root) {
        int depth = 0;
        if(root!=null){
            int l = maxDepth(root.left);
            int r = maxDepth(root.right);
            depth = l>r?l+1:r+1;
        }
        return depth;
    }
}
```

## 107. Binary Tree Level Order Traversal II
```
import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections; 
class Solution {
    List<List<Integer>> ans = null;
    List<Integer> tmp = null;
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        ans = new ArrayList();
        tmp = new ArrayList();
        if(root==null)
            return ans;
        visit(root);
        reverse(ans);
        return ans;
    }
    public void visit(TreeNode root){
        Queue<TreeNode> q = new LinkedList();
        Queue<TreeNode> tq = new LinkedList();
        if(root==null)
            return;
        q.offer(root);
        while(q.peek()!=null){
            TreeNode tn = q.poll();
            tmp.add(tn.val);
            if(tn.left!=null)
                tq.offer(tn.left);
            if(tn.right!=null)
                tq.offer(tn.right);
            if(q.peek()==null){
                ans.add(tmp);
                tmp = new ArrayList();
                q = tq;
                tq = new LinkedList();
            }
        }
    }
    public void reverse(List<List<Integer>> lps){
        Collections.reverse(lps);
    }
}
```

## 111. Minimum Depth of Binary Tree
```
class Solution {
    public int minDepth(TreeNode root) {
        //原子操作
        if(root==null)
            return 0;
        if(root.left==null&&root.right==null)
            return 1;
        
        if(root.left==null)
            return minDepth(root.right)+1;
        else if(root.right==null)
            return minDepth(root.left)+1;
        else
            return Math.min(minDepth(root.left),minDepth(root.right))+1;
    }
}
```
## 112. Path Sum
```
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        
        if(root==null)
            return false;
        else if(root.left==null&&root.right==null&&sum==root.val){
                return true;
        }
        else{
            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);
        }
        
    }
}
```

## 118. 帕斯卡三角形
```
class Solution {
    public List<List<Integer>> generate(int numRows) {     
        if(numRows==0){
            List<List<Integer>> ans = new ArrayList();
            return ans;
        }                   
        if(numRows==1){
            List<Integer> list = new ArrayList();
            list.add(1);
            List<List<Integer>> ans = new ArrayList();
            ans.add(list);
            return ans;
        }       
        List<List<Integer>> ans = new ArrayList();
        for(int i=0;i<numRows;i++){
            List<Integer> list = new ArrayList();
            for(int j=0;j<i+1;j++){
                
                if(j==0)
                    list.add(1);
                else if(j==i){
                    list.add(1);
                }
                else{
                    list.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j));
                }
            }  
            ans.add(list);
        }          
        return ans;
    }
}
```

## 136. 只出现一次的数字
```
class Solution {
    public int singleNumber(int[] nums) {
        if(nums.length==1)
            return nums[0];
        Map<Integer,Integer> mmp = new HashMap();
        for(int i=0;i<nums.length;i++){
            mmp.put(nums[i],mmp.getOrDefault(nums[i],0)+1);
        }
        for(Map.Entry<Integer,Integer> entry:mmp.entrySet()){
            if(entry.getValue()==1)
                return entry.getKey();
        }
        return 0;
        
        int tmp = 0;
        for(int i=0;i<nums.length;i++)
            tmp ^= nums[i];
        return tmp;
    }
}
```

## 144. Binary Tree Preorder Traversal
```
import java.util.List;
import java.util.ArrayList;
class Solution {
    private List<Integer> l = null;
    public List<Integer> preorderTraversal(TreeNode root) {
        l = new ArrayList();
        if(root==null)
            return new ArrayList();
        visit(root);
        return l;
    }
    public void visit(TreeNode root){
        if(root==null)
            return;
        l.add(root.val);
        visit(root.left);
        visit(root.right);
    }
}
```

## 145. Binary Tree Postorder Traversal
```
import java.util.List;
import java.util.ArrayList;
class Solution {
    private List<Integer> l = null;
    public List<Integer> postorderTraversal(TreeNode root) {
        l = new ArrayList();
        if(root==null)
            return l;
        visit(root);
        return l;
    }
    public void visit(TreeNode root){
        if(root==null)
            return;
        visit(root.left);
        visit(root.right);
        l.add(root.val);
    }
}
```

## 162. 寻找峰值
```
class Solution {
    public int findPeakElement(int[] nums) {
        int left=0, right=nums.length-1;
        while(left<right){
            int mid = (left+right)/2;
            if(nums[mid]<nums[mid+1])
                left=mid+1;
            else
                right=mid;
        }
        return left;
    }
}
```

## 167. Two Sum II - Input array is sorted
```
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int index1 = 0;
        int index2 = 0;
        out:
        for(int i=0;i<numbers.length;i++){
            for(int j=i+1;j<numbers.length;j++){
                
                if(numbers[i] + numbers[j] > target){
                    break;
                }
                if(numbers[i] + numbers[j] == target){
                    index1 = i;
                    index2 = j;
                    break out;
                }
            }
        }
        int[] ans = new int[2];
        ans[0] = index1+1;
        ans[1] = index2+1;
        return ans;
    }
}
```

## 169. Majority Element
```
import java.util.Map;
import java.util.HashMap;
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer,Integer> mmp = new HashMap();       
        for (int i=0;i<nums.length;i++){
            int ans = mmp.getOrDefault(nums[i], 0);
            mmp.put(nums[i], ans+1);
        }
        int max = 0;
        int index = 0;
        for (Map.Entry<Integer, Integer> entry : mmp.entrySet()) { 
            if(entry.getValue()>max){
                index = entry.getKey();
                max = entry.getValue();
            }       
        }
        return index;
    }
}
```

## 173. Binary Search Tree Iterator
```
import java.util.Stack;
public class BSTIterator {
    
    Stack<TreeNode> s = null;
    
    public BSTIterator(TreeNode root) {
        s = new Stack();
        if (root == null){
            return ;
        }
        TreeNode node = root;
        while(node!=null){
            s.push(node);
            node = node.left;
        }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        if(s.isEmpty())
            return false;
        else
            return true;
    }

    /** @return the next smallest number */
    public int next() {
        TreeNode node = s.pop();
        int ans = node.val;
        if(node.right!=null){
            node = node.right;
            while(node!=null){
                s.push(node);
                node = node.left;
            }
        }
        return ans;
    }
    
}
```

## 172*. 阶乘后的零
```java
class Solution {
    public int trailingZeroes(int n) {
        //考虑25！,25可以分解为5*5,不能简单返回n/5，计算n/5， 还要计算n/5/5, n/5/5/5, n/5/5/5/5, ..., n/5/5/5,,,/5直到商为0。
        if(n==0)
            return 0;
        int sum=0;
        while(n>0){
            sum += n/5;
            n /= 5;
        }
        return sum;
    }
}
```

## 264*. Ugly Number II
```java
import java.util.List;
class Solution {
    public int nthUglyNumber(int n) {      
       List<Integer> l = new ArrayList();
       l.add(1);
       int r2 = 0, r3 = 0, r5 = 0;
       while(l.size() < n){
            int m2 = l.get(r2)*2;
            int m3 = l.get(r3)*3;
            int m5 = l.get(r5)*5;
            int min = Math.min(m2,Math.min(m3,m5));
            l.add(min);
            if(m2==min)
                r2++;
            if(m3==min)
                r3++;
            if(m5==min)
                r5++;
       }
       return l.get(l.size()-1);            
    }
}
```

## 665*. 非递减数列
```java
class Solution {
    public boolean checkPossibility(int[] nums) {
        if(nums.length==0||nums.length==1)
            return true;
        int cnt = 0;
        for(int i=1;i<nums.length&&cnt<=1;i++){
            if(nums[i-1]>nums[i]){
                cnt++;
                if(i-2<0||nums[i-2]<=nums[i])
                    nums[i-1] = nums[i];
                else
                    nums[i] = nums[i-1];
            }
        }       
        return cnt<=1;
    }    
}
```


