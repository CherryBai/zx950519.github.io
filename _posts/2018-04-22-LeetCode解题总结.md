---
layout:     post
title:      LeetCode解题总结
subtitle:   个人向解题思路汇总(Java实现)
date:       2018-04-22
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - LeetCode
    - Java
    - 总结
---

>不积跬步 无以至千里

## 22. 括号生成
```
class Solution {   
    public List<String> ans = new ArrayList();    
    public List<String> generateParenthesis(int n) {   
        if(n==1){
            ans.add("()");
            return ans;
        }
        String path = "";
        Func(n, n, path);  
        return ans;
    }
    public void Func(int left, int right, String path){        
        if(left==0&&right==0){
            ans.add(path);
            return;
        }
        if(left!=0)
            Func(left-1,right,path+"(");
        if(right!=0&&left<right)
            Func(left,right-1,path+")");
    }
}
```

## 100. Same Tree
``` javascript
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null)
            return true;
        else if(p==null&&q!=null)
            return false;
        else if(p!=null&&q==null)
            return false;
        else{
            if(p.val!=q.val)
                return false;
            else
                return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
        }          
    }
}
```

## 104. Maximum Depth of Binary Tree
```
class Solution {
    public int maxDepth(TreeNode root) {
        int depth = 0;
        if(root!=null){
            int l = maxDepth(root.left);
            int r = maxDepth(root.right);
            depth = l>r?l+1:r+1;
        }
        return depth;
    }
}
```

## 107. Binary Tree Level Order Traversal II
```
import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections; 
class Solution {
    List<List<Integer>> ans = null;
    List<Integer> tmp = null;
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        ans = new ArrayList();
        tmp = new ArrayList();
        if(root==null)
            return ans;
        visit(root);
        reverse(ans);
        return ans;
    }
    public void visit(TreeNode root){
        Queue<TreeNode> q = new LinkedList();
        Queue<TreeNode> tq = new LinkedList();
        if(root==null)
            return;
        q.offer(root);
        while(q.peek()!=null){
            TreeNode tn = q.poll();
            tmp.add(tn.val);
            if(tn.left!=null)
                tq.offer(tn.left);
            if(tn.right!=null)
                tq.offer(tn.right);
            if(q.peek()==null){
                ans.add(tmp);
                tmp = new ArrayList();
                q = tq;
                tq = new LinkedList();
            }
        }
    }
    public void reverse(List<List<Integer>> lps){
        Collections.reverse(lps);
    }
}
```

## 111. Minimum Depth of Binary Tree
```
class Solution {
    public int minDepth(TreeNode root) {
        //原子操作
        if(root==null)
            return 0;
        if(root.left==null&&root.right==null)
            return 1;
        
        if(root.left==null)
            return minDepth(root.right)+1;
        else if(root.right==null)
            return minDepth(root.left)+1;
        else
            return Math.min(minDepth(root.left),minDepth(root.right))+1;
    }
}
```
## 112. Path Sum
```
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        
        if(root==null)
            return false;
        else if(root.left==null&&root.right==null&&sum==root.val){
                return true;
        }
        else{
            return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);
        }
        
    }
}
```

## 118. 帕斯卡三角形
```
class Solution {
    public List<List<Integer>> generate(int numRows) {     
        if(numRows==0){
            List<List<Integer>> ans = new ArrayList();
            return ans;
        }                   
        if(numRows==1){
            List<Integer> list = new ArrayList();
            list.add(1);
            List<List<Integer>> ans = new ArrayList();
            ans.add(list);
            return ans;
        }       
        List<List<Integer>> ans = new ArrayList();
        for(int i=0;i<numRows;i++){
            List<Integer> list = new ArrayList();
            for(int j=0;j<i+1;j++){
                
                if(j==0)
                    list.add(1);
                else if(j==i){
                    list.add(1);
                }
                else{
                    list.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j));
                }
            }  
            ans.add(list);
        }          
        return ans;
    }
}
```

## 136. 只出现一次的数字
```
class Solution {
    public int singleNumber(int[] nums) {
        if(nums.length==1)
            return nums[0];
        Map<Integer,Integer> mmp = new HashMap();
        for(int i=0;i<nums.length;i++){
            mmp.put(nums[i],mmp.getOrDefault(nums[i],0)+1);
        }
        for(Map.Entry<Integer,Integer> entry:mmp.entrySet()){
            if(entry.getValue()==1)
                return entry.getKey();
        }
        return 0;
        
        int tmp = 0;
        for(int i=0;i<nums.length;i++)
            tmp ^= nums[i];
        return tmp;
    }
}
```

## 144. Binary Tree Preorder Traversal
```
import java.util.List;
import java.util.ArrayList;
class Solution {
    private List<Integer> l = null;
    public List<Integer> preorderTraversal(TreeNode root) {
        l = new ArrayList();
        if(root==null)
            return new ArrayList();
        visit(root);
        return l;
    }
    public void visit(TreeNode root){
        if(root==null)
            return;
        l.add(root.val);
        visit(root.left);
        visit(root.right);
    }
}
```

## 145. Binary Tree Postorder Traversal
```
import java.util.List;
import java.util.ArrayList;
class Solution {
    private List<Integer> l = null;
    public List<Integer> postorderTraversal(TreeNode root) {
        l = new ArrayList();
        if(root==null)
            return l;
        visit(root);
        return l;
    }
    public void visit(TreeNode root){
        if(root==null)
            return;
        visit(root.left);
        visit(root.right);
        l.add(root.val);
    }
}
```

## 162. 寻找峰值
```
class Solution {
    public int findPeakElement(int[] nums) {
        int left=0, right=nums.length-1;
        while(left<right){
            int mid = (left+right)/2;
            if(nums[mid]<nums[mid+1])
                left=mid+1;
            else
                right=mid;
        }
        return left;
    }
}
```

## 167. Two Sum II - Input array is sorted
```
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int index1 = 0;
        int index2 = 0;
        out:
        for(int i=0;i<numbers.length;i++){
            for(int j=i+1;j<numbers.length;j++){
                
                if(numbers[i] + numbers[j] > target){
                    break;
                }
                if(numbers[i] + numbers[j] == target){
                    index1 = i;
                    index2 = j;
                    break out;
                }
            }
        }
        int[] ans = new int[2];
        ans[0] = index1+1;
        ans[1] = index2+1;
        return ans;
    }
}
```

## 169. Majority Element
```
import java.util.Map;
import java.util.HashMap;
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer,Integer> mmp = new HashMap();       
        for (int i=0;i<nums.length;i++){
            int ans = mmp.getOrDefault(nums[i], 0);
            mmp.put(nums[i], ans+1);
        }
        int max = 0;
        int index = 0;
        for (Map.Entry<Integer, Integer> entry : mmp.entrySet()) { 
            if(entry.getValue()>max){
                index = entry.getKey();
                max = entry.getValue();
            }       
        }
        return index;
    }
}
```

## 172*. 阶乘后的零
```java
class Solution {
    public int trailingZeroes(int n) {
        //考虑25！,25可以分解为5*5,不能简单返回n/5，计算n/5， 还要计算n/5/5, n/5/5/5, n/5/5/5/5, ..., n/5/5/5,,,/5直到商为0。
        if(n==0)
            return 0;
        int sum=0;
        while(n>0){
            sum += n/5;
            n /= 5;
        }
        return sum;
    }
}
```

## 173. Binary Search Tree Iterator
```
import java.util.Stack;
public class BSTIterator {
    
    Stack<TreeNode> s = null;
    
    public BSTIterator(TreeNode root) {
        s = new Stack();
        if (root == null){
            return ;
        }
        TreeNode node = root;
        while(node!=null){
            s.push(node);
            node = node.left;
        }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        if(s.isEmpty())
            return false;
        else
            return true;
    }

    /** @return the next smallest number */
    public int next() {
        TreeNode node = s.pop();
        int ans = node.val;
        if(node.right!=null){
            node = node.right;
            while(node!=null){
                s.push(node);
                node = node.left;
            }
        }
        return ans;
    }
    
}
```

## 202. Happy Number
```
class Solution {
    public boolean isHappy(int n) {
        if(n<10){
            if(n==1||n==7)
                return true;
        }
        
        int nn = n;
        while(nn>=10){
            int sum = 0;
            while(nn>0){
                sum += (nn%10)*(nn%10);
                nn/=10;
            }
            nn = sum;
        }
        if(nn==1||nn==7)
            return true;
        else
            return false;
        
    }
}
```

## 204. Count Primes
```
class Solution {
    public int countPrimes(int n) {
        
        if(n<=2)
            return 0;
        if(n==3)
            return 1;
        if(n==4)
            return 2;
        
        int[] ai = new int[n+1];
        for(int i=2;i<n;i++)
            ai[i] = 1;
        ai[0]=0;
        ai[1]=0;
        int max = (int)Math.sqrt(n);
        for(int i=2;i<=max;i++){
            if(ai[i]==0)
                continue;
            for(int j=i*i;j<n;j+=i)
                ai[j]=0;
        }
        
        int sum=0;
        for(int i=2;i<n;i++)
            if(ai[i]==1)
                sum++;
        return sum;
    }
}
```

## 217. 存在重复
```
class Solution {
    public boolean containsDuplicate(int[] nums) {
        if(nums.length==0)
            return false;
        Map<Integer,Boolean> mmp = new HashMap();
        for(int i=0;i<nums.length;i++){
            if(mmp.getOrDefault(nums[i],false)==false)
                mmp.put(nums[i],true);
            else
                return true;
        }
        
        return false;
    }
}
```

## 226. Invert Binary Tree
```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null)
            return null;
        function(root);
        return root;
    }
    public void function(TreeNode root){
        if(root==null)
            return;
        else{
            TreeNode tmp = root.left;
            root.left = root.right;
            root.right = tmp;
            function(root.left);
            function(root.right);
        }
    }
}
```

## 228. 汇总区间
```
class Solution {
    public List<String> summaryRanges(int[] nums) {
        if(nums.length==0)
            return new ArrayList();
        List<String> ans = new ArrayList();
        if(nums.length==1){
            ans.add((nums[0])+"");
            return ans;
        }
            
        int start = 0, end = 0;
        
        for(int i=1;i<nums.length;i++){
            if(nums[i]-nums[i-1]!=1){
                //区间长度为0
                if(start==i-1){
                    ans.add(""+nums[start]);
                }
                //区间长度大于0
                else{
                    ans.add(nums[start]+"->"+nums[i-1]);
                }
                start=i;
            }
            else{
                continue;
            }
        }
        if(nums[nums.length-1]-nums[nums.length-2]==1)
            ans.add(nums[start]+"->"+nums[nums.length-1]);
        else
            ans.add(nums[nums.length-1]+"");
        
        return ans;
    }
}
```

## 229. 求众数 II
```
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        
        if(nums.length==0)
            return new ArrayList();
        
        List<Integer> lpl = new ArrayList();
        Map<Integer,Integer> mmp = new HashMap();
        for(int i=0;i<nums.length;i++){
            mmp.put(nums[i], mmp.getOrDefault(nums[i], 0)+1);
        }
        for(Map.Entry<Integer, Integer> entry:mmp.entrySet()){
            if(entry.getValue()>nums.length/3)
                lpl.add(entry.getKey());
        }
        return lpl;
    }
}
```
## 230. Kth Smallest Element in a BST
```
class Solution {
    private int index = 0;
    private int ans = 0;
    public int kthSmallest(TreeNode root, int k) {
        visit(root,k);
        return ans;
    }
    
    public void visit(TreeNode root,int k){
        if(root==null)
            return;
        visit(root.left,k);
        ++index;
        if(index>k)
            return;
        if(index==k){
            ans = root.val;
            return;
        }    
        visit(root.right,k);
    }
}
```

## 264*. Ugly Number II
```java
import java.util.List;
class Solution {
    public int nthUglyNumber(int n) {      
       List<Integer> l = new ArrayList();
       l.add(1);
       int r2 = 0, r3 = 0, r5 = 0;
       while(l.size() < n){
            int m2 = l.get(r2)*2;
            int m3 = l.get(r3)*3;
            int m5 = l.get(r5)*5;
            int min = Math.min(m2,Math.min(m3,m5));
            l.add(min);
            if(m2==min)
                r2++;
            if(m3==min)
                r3++;
            if(m5==min)
                r5++;
       }
       return l.get(l.size()-1);            
    }
}
```

## 665*. 非递减数列
```java
class Solution {
    public boolean checkPossibility(int[] nums) {
        if(nums.length==0||nums.length==1)
            return true;
        int cnt = 0;
        for(int i=1;i<nums.length&&cnt<=1;i++){
            if(nums[i-1]>nums[i]){
                cnt++;
                if(i-2<0||nums[i-2]<=nums[i])
                    nums[i-1] = nums[i];
                else
                    nums[i] = nums[i-1];
            }
        }       
        return cnt<=1;
    }    
}
```


