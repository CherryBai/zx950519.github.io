## 4.1 区别

## ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？
- Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。
- Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。
- Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。

##  简述ArrayList和LinkedList的区别
- 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；
- 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）
- 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。
- 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。
- 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。

## 为什么ArrayList的查询时间复杂度为O（1）？为什么数组查询可以到O（1）
ArrayList支持快速随机访问，即通过序号传参获得对象，get(int index)方法。  

## 4.2 ArrayList的resize过程

- boolean add(E e):先调用void ensureCapacityInternal(size+1)确保添加后数组不越界，返回后添加数据
- void ensureCapacityInternal(int minCapacity)：获取默认容量和传入参数的较大者，然后调用ensureExplicitCapacity(minCapacity)
- void ensureExplicitCapacity(int minCapacity)：modCount自增；参数值大于当前数组长度，进行扩容，调用grow(minCapacity)
- void grow(int minCapacity)：进行扩容，每次设定新容量为旧容量的1.5倍(int newCapacity = oldCapacity + (oldCapacity >> 1))

## ArrayList如何高效使用
在需要大量添加元素的时候，调用ensureCapacity(int minCapacity)，进行预扩容。

## 在ArrayList中经常出现Arrays.copyOf()与System.arraycopy()，二者区别是什么？
- Arrays.copyOf()内部实际调用了System.arraycopy()方法
- System.arraycopy() 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置
- Arrays.copyOf()是系统自动在内部新建一个数组，并返回该数组

## 简述List遍历的选择优先级
- 实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach,
- 未实现 RandomAccess接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环

## 简述ArrayList的删除过程
需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。

## 简述你对Arrays.asList()的认识
asList()是Arrays类下的一个方法，用于将数组装换成List。在使用时需要注意的是，传入的数组必须是对象数组，而不能是基本类型数组。当传入一个基本类型数组时，Arrays.asList()真正得到的参数不是数组中的元素，而是数组本身导致List只存在一个元素，即这个数组。为了解决这一问题，使用基本类型的包装类即可。此外，在转换为List后不能使用集合修改方法add()、remove()、clear()等方法，否则会抛出异常。造成这一现象的原因是方法返回的并不是新的java.util.ArrayList，而是Arrays的一个内部类，这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。而且，通过对数组的修改，会使得List中的对应值也发生改变。  

正确使用Arrays.asList()的姿势：  
```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"))
```
```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
```
