---
layout:     post
title:      数论
subtitle:   数论中的一些常用知识&模板
date:       2018-06-09
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数论
    - 总结 
---

## 丑数

```
1. 输出第n个丑数
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if (index < 1)
            return 0;
        if (index == 1)
            return 1;
        int a = 0, b = 0, c = 0;
        int[] tmp = new int[index+1];
        tmp[0] = 1;
        for (int i = 1;i < index;i++) {
            tmp[i] = Math.min(Math.min(2*tmp[a], 3*tmp[b]), 5*tmp[c]);
            if (tmp[i] == 2*tmp[a]) {
                a++;
                
            }
            if (tmp[i] == 3*tmp[b]){
                 b++;
                
            }
            if (tmp[i] == 5*tmp[c]){
                c++;
            }
        }
        return tmp[index-1];
    }
}
2.

3.
```

## 素数打表
&emsp;&emsp;用于求素数相关问题的基础范围  

```
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int end = scanner.nextInt();
        int index = 3;
        int cnt = 1;
        while (true) {
            if(isPrime(index))
                cnt++;
            if(cnt==end) {
                System.out.println(index);
                break;
            }
            index++;
        }

    }

    public static boolean isPrime(int n) {
        if(n==2||n==3)
            return true;
        for(int i=2; i*i<=n; i++) {
            if(n%i==0)
                return false;
        }
        return true;
    }
}
```

- 1. 第100个素数：541  
- 2. 第1000个素数：7919
- 3. 第5000个素数：48611
- 4. 第10000个素数：104729
- 5. 第50000个素数：611953
- 6. 第100000个素数：1299709

## 素数筛
&emsp;&emsp;快速求指定范围内的所有素数
```
public static Vector<Integer> getPrimeVectorData(int size) {
        boolean[] data = new boolean[size+1];
        for(int i=2; i<=size/2; i++) {
            int factor = 2;
            while(true) {
                if(i*factor<=size) {
                    data[i*factor] = true;
                }
                else {
                    break;
                }
                factor++;
            }
        }
        Vector<Integer> vector = new Vector<>();
        for(int i=2; i<=size; i++) {
            if(data[i] == false)
                vector.add(i);
        }
        return vector;
    }
```

```
public static Map<Integer, Integer> getPrimeVectorData(int size) {
        boolean[] data = new boolean[size+1];
        for(int i=2; i<=size/2; i++) {
            int factor = 2;
            while(true) {
                if(i*factor<=size) {
                    data[i*factor] = true;
                }
                else {
                    break;
                }
                factor++;
            }
        }
        Map<Integer, Integer> mmp = new LinkedHashMap<>();
        for(int i=2; i<=size; i++) {
            if(data[i] == false)
                mmp.put(i, 1);
        }
        return mmp;
    }
```

## 最大公约数&最小公倍数

&emsp;&emsp;对于最大公约数和最小公倍数的求解方法，利用辗转相除法(欧几里德算法)即可。先求出最大公约数，再求出最小公倍数。  

```
    // 循环法实现辗转相除
    public static long gcd_1(long a, long b) {
        long k = 0;
        do {
            // 得到余数
            k = a % b;
            // 根据辗转相除法,把被除数赋给除数
            a = b;
            // 余数赋给被除数
            b = k;
        } while(k != 0);
        // 返回被除数
        return a;
    }
    // 循递归法实现辗转相除
    public static long gcd_2(long a, long b) {
        if(b == 0) {
            return a;
        }
        if(a < 0) {
            return gcd_2(-a, b);
        }
        if(b < 0) {
            return gcd_2(a, -b);
        }
        return gcd_2(b, a % b);
    }
```

## 同余与模运算  

```
(a+b) mod n = ((a mod n)+(b mod n)) mod n
(a-b) mod n = ((a mod n)-(b mod n) + n) mod n
(a*b) mod n = (a mod n)(b mod n) mod n
```

## 扩展欧几里得

&emsp;&emsp;扩展欧几里得算法就是在求 a,b 的最大公约数 m=gcd(a,b) 的同时，求出贝祖等式ax + by = m的一个解 (x,y)。  

#### 贝祖等式

&emsp;&emsp;对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程（称为裴蜀等式）:ax + by = m 有整数解时当且仅当m是d的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x, y都称为裴蜀数，可用扩展欧几里得算法(Extended Euclidean algorithm)求得。例如，12和42的最大公因数是6，则方程12x+42y=6有解。事实上有(-3)×12 + 1×42 = 6及4×12 + (-1)×42 = 6。特别来说，方程 ax+by=1 有整数解当且仅当整数a和b互素。

#### 求解二元一次方程的实例(Java)
&emsp;&emsp;递归版  

```
public class Main {

    public static int x = 0;
    public static int y = 0;

    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        int r = exgcd(47, 30);
        System.out.println("r = " + r);
        System.out.println("x = " + x);
        System.out.println("y = " + y);
    }

    public static int exgcd(int a, int b) {
        if(b == 0) {
            x = 1;
            y = 0;
            return a;
        }
        int r = exgcd(b, a%b);
        int t = y;
        y = x - (a/b)*y;
        x = t;
        return r;
    }

}
```

&emsp;&emsp;递归过程为：  

```
exgcd(47, 30, x, y)
 {
     r = exgcd(30, 17，x, y)
     {
         r = exgcd(17, 13, x, y)
         {
             r = exgcd(13, 4, x, y)
             {
                 r = exgcd(4, 1, x, y)
                 {
                     r = exgcd(1, 0, x, y)
                     {
                         x = 1; 
                         y = 0;
                         return 1;
                     }
                     t = y = 0;
                     y = x - (4/1) * y = 1;
                     x = t = 0;
                     return r = 1; 
                 }
                 t = 1;
                 y = 0 - (13/4) * 1 = -3;
                 x = 1;
                 return 1;
             }
             t = -3;
             y = 1 - (17/13) * (-3) = 4;
             x = -3;
             return 1;
         }
         t = 4;
         y = -3 - (30/17) * 4 = -7;
         x = 4;
         return 1;
     }
     t = -7;
     y = 4 - (47/30) * (-7) = 11;
     x = -7;
     return 1;
 }
```
&emsp;&emsp;非递归版  

```
public class Main {

    public static int x = 0;
    public static int y = 0;

    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        int r = exgcdS(47, 30);
        System.out.println("r = " + r);
        System.out.println("x = " + x);
        System.out.println("y = " + y);
    }
    
    public static int exgcdS(int m, int n) {
        if (n == 0) {
            x = 1; y = 0;
            return m;
        }
        int a, a1, b, b1, c, d, q, r, t;
        a1 = b = 1;
        a = b1 = 0;
        c = m; d = n;

        q = c/d;
        r = c%d;
        while (r>0) {
            c = d;
            d = r;
            t = a1;
            a1 = a;
            a = t - q * a;
            t = b1;
            b1 = b;
            b = t - q * b;

            q = c/d;
            r = c%d;
        }
        x = a; y = b;
        return d;
    }

}
```

#### 乘法逆元  

&emsp;&emsp;就本人目前的认识，乘法逆元主要使用与除法取模的场景中。由于除法取模无法展开，一个解决办法是将除法变成乘法，除了变换运算符号，还要讲除数变成乘数，乘法逆元可以解决将原来的除数怎么变成新的乘数这一过程。例如(12 / 4) mod 7 = 3, 我们可以通过乘法逆元将这个过程变为(12 * 2) mod 7 = 3，这个4->2就是乘法逆元所做的工作。定理为：如果ax≡1 (mod p),且gcd(a,p)=1（a与p互质），则称a关于模p的乘法逆元为x。  

&emsp;&emsp;例如，求5关于模14的乘法逆元，值为2。即(n/5)%14与(n*2)%14结果一致。  

&emsp;&emsp;C++模板：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define LL long long
int inv[1000010];

LL ksm(LL a,LL b,LL mod){
    int ans=1;
    while(b){
        if(b&1) ans=(ans*a)%mod;
        a=(a*a)%mod;
        b>>=1;
    }
    return ans;
} 

LL exgcd(LL a,LL b,LL &x,LL &y){
    if(!b){
        x=1;
        y=0;
        return a;
    }
    LL GCD=exgcd(b,a%b,x,y);
    LL tmp=x;
    x=y;
    y=tmp-a/b*y;
    return GCD;
}

//扩展欧几里得求逆元
LL inv1(LL a,LL mod) {
    LL x,y;
    LL d=exgcd(a,mod,x,y);
    if(d==1) return (x%mod+mod)%mod;
    return -1;
}

//费马小定理
LL inv2(LL a,LL mod){
    return ksm(a,mod-2,mod);
} 

//线性递推求逆元 
void inv3(LL mod){
    inv[1]=1;
    for(int i=2;i<=mod-1;i++){
        inv[i]=(mod-mod/i)*inv[mod%i]%mod;
        cout<<inv[i]<<" ";
    }
}

int main()
{
    LL n,mod;
    while(cin>>n>>mod){
        cout<<inv1(n,mod)<<endl;
    }

} 
```

## 全错排问题  

&emsp;&emsp;一个很经典的数学问题：有一个人写了n封信件，对应n个信封，然而粗心的秘书却把所有信件都装错了信封，那么一共有多少种装错的装法？这个问题可抽象为以下一个数学问题：已知一个长度为n的有序序列｛a1,a2,a3,…,an｝，打乱其顺序，使得每一个元素都不在原位置上，则一共可以产生多少种新的排列？  

&emsp;&emsp;设长度为n的序列的全错位排列一共有f(n)种，假设我们已经解决了f(1)到f(n-1)，那么当序列新增了一个元素an，显然全错位排列中该元素不能放在第n个位置上，假设该元素在从1到n-1的第i个位置，那么在新序列中第n个位置上的元素可能有两种情况：  

- 1.第n个位置上的元素为ai。因为an和ai都不在原位置上，因此只需剩余的元素都是全错位排列，新序列就构成了全错位排列。那么除去ai和an还剩下n-2个元素，则这n-2个元素一共有f(n-2)种全错位排列，因为i的选择共有n-1种，因此该情况下一共有(n-1)*f(n-2)种全错位排列。  

- 2.第n个位置上的元素不为ai。该种情况相当于，前n-1个元素做好了全错位排列，an与其中任意元素交换位置，新生成的序列也是一个全错位排列。这种情况下i的选择共有n-1种，n-1的元素的全错位排列共有f(n-1)种，因此该情况下一共有(n-1)*f(n-1)种全错位排列。  

&emsp;&emsp;综合以上两种情况，f(n)=(n-1)f(n-2)+(n-1)*f(n-1)=(n-1)[f(n-2)+f(n-1)]   


```
public class Main {

    public static void main(String[] args) throws Exception{
        Scanner scanner = new Scanner(System.in);
        String[] data = new String[21];
        data[1] = "0";
        data[2] = "1";
        for(int i=3; i<=20; i++) {
            data[i] = new BigDecimal(String.valueOf(i-1))
                    .multiply(new BigDecimal(data[i-1])
                            .add(new BigDecimal(data[i-2])))
                                .toString();
        }
//        System.out.println(data[size]);
        while (scanner.hasNext()) {
            int tmp = scanner.nextInt();
            System.out.println(data[tmp]);
        }
    }
}
```

## 全排列问题(一共有多少种排列方式)

&emsp;&emsp;字典序法：  

- 从排列的右端开始，找出第一个比右边数字小的数字的序号j（j从左端开始计算）
- 在pj的右边的数字中，找出所有比pj大的数中最小的数字pk，即 k=max{i|pi>pj}（右边的数从右至左是递增的，因此k是所有大于pj的数字中序号最大者）
- 对换pi，pk
- 再将pj+1......pk-1pkpk+1pn倒转得到排列p''=p1p2.....pj-1pjpn.....pk+1pkpk-1.....pj+1，这就是排列p的下一个下一个排列。

&emsp;&emsp;例如839647521是数字1～9的一个排列。从它生成下一个排列的步骤如下：自右至左找出排列中第一个比右边数字小的数字4 839647521;在该数字后的数字中找出比4大的数中最小的一个5 839647521;将5与4交换 839657421;将7421倒转 839651247;所以839647521的下一个排列是839651247。
```
// 字典法
class DictionaryPermutation {

    private char[] data;
    private int length;

    public Vector<String> getPermutateData(String input) {
        Vector<String> vector = new Vector<>();
        // change the data type to we needed
        changeToData(input);
        // sort the data from small to big
        Arrays.sort(data);
        // output all the order
        vector.add(String.valueOf(data));
        while (nextPermutate()) {
            vector.add(String.valueOf(data));
        }
        return vector;
    }

    public void permutate(String input) {
        // change the data type to we needed
        changeToData(input);
        // sort the data from small to big
        Arrays.sort(data);
        // output all the order
        System.out.println(data);
        while (nextPermutate()) {
            System.out.println(data);
        }
    }

    private void changeToData(String input) {
        if (input == null)
            return;
        data = input.toCharArray();
        length = data.length;
    }

    private boolean nextPermutate() {
        int end = length - 1;
        int swapPoint1 = end, swapPoint2 = end;
        // the actual swap-point is swapPoint1 - 1
        while (swapPoint1 > 0 && data[swapPoint1] <= data[swapPoint1 - 1])
            swapPoint1--;
        if (swapPoint1 == 0)
            return false;
        else {
            while (swapPoint2 > 0 && data[swapPoint2] <= data[swapPoint1 - 1])
                swapPoint2--;
            swap(data, swapPoint1 - 1, swapPoint2);
            reverse(data, swapPoint1, end);
            return true;
        }
    }

    private void swap(char[] data, int left, int right) {
        char temp = data[left];
        data[left] = data[right];
        data[right] = temp;
    }

    private void reverse(char[] data, int left, int right) {
        for (int i = left, j = right; i < j; i++, j--)
            swap(data, i, j);
    }

}
```

&emsp;&emsp;递归法：去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换。

```
// 递归法
class RecursionPermutation {

    public static Vector<String> vector = new Vector<>();

    public static void permutate(String input){
        if(input == null)
            throw new IllegalArgumentException();
        char[] data = input.toCharArray();
        permutate(data, 0);
    }

    public static Vector<String> getPermutateData(String str) {
        vector.removeAllElements();
        permutate(str);
        return vector;
    }

    public static void permutate(char[] data, int begin){
        int length = data.length;
        if(begin == length) {
            System.out.println(data);
            vector.add(String.valueOf(data));
        }
        for(int i = begin ; i < length; i++)
        {
            if(isUnique(data, begin, i)){
                swap(data, begin, i);
                permutate(data, begin + 1);
                swap(data, begin, i);
            }
        }
    }

    private static boolean isUnique(char[] data, int begin, int end){
        for(int i = begin; i < end; i++)
            if(data[i] == data[end])
                return false;
        return true;
    }

    private static void swap(char[] data, int left, int right) {
        char temp = data[left];
        data[left] = data[right];
        data[right] = temp;
    }
    
}
```

## 分解因数

&emsp;&emsp;所谓因子分解，就是把给定的正整数a，分解成若干个素数的乘积，即 a = a1 × a2 × a3 × ... × an,并且 1 < a1 ≤ a2 ≤ a3 ≤ ... ≤ an。其中a1、a2、...、an均为素数。 先给出一个整数a，请输出分解后的因子。例如：18 = 2 * 3 * 3。  

```
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            int data = scanner.nextInt();
            System.out.print(data + " =");
            for(int i=2; i<=Math.sqrt(data); i++) {
                while (data!=i) {
                    if(data%i==0) {
                        System.out.print(" " + i + " *");
                        data /= i;
                    }
                    else
                        break;
                }
            }
            System.out.println(" " + data);
        }

    }
}
```

## 找假币
&emsp;&emsp;问题本质：从一堆同类物中，找出唯一的异类。
&emsp;&emsp;思路：分3份(分3份比2份的找到硬币所需次数少)，当硬币不是3的倍数时，可能余数为1或者2，假设余1，最多的那一份继续分，假设余2，两份最多的其中一份继续分，因为是要求最多的次数，两种情况均满足n=n/3+1
```
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            int data = scanner.nextInt();
//            if(data==0)
//                break;
//            if(data==1) {
//                System.out.println(0);
//                continue;
//            }
//            if(data<=3) {
//                System.out.println(1);
//                continue;
//            }
//            System.out.println(solution(data));
            int count = 0;
            while (data>1) {
                data = data/3 + 1 - (data % 3 ^ 3) / 3;
                count++;
            }
            System.out.println(count);
        }
    }

    public static int solution(int data) {
        int res = 1;
        while (data>3) {
            if(data%3==0) {
                data /= 3;
            }
            else {
                data = data/3 + 1;
            }
            res++;
        }
        return res;
    }
}
```

## 2Sum问题
&emsp;&emsp;问题本质：利用数组左右指针移动，暴力法得分低  
&emsp;&emsp;链接：https://leetcode-cn.com/problems/two-sum/description/  

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        if(nums.length==0) {
			    return null;
		    }
		int slow = 0;
        int fast = nums.length-1;
        int[] backup = deepcopy(nums);
        int[] res = new int[2];
        Arrays.sort(nums);
        boolean flag = false;
        while(slow<fast) {
            int tmp = nums[slow]+nums[fast];
            if(tmp==target) {
                flag = true;
                break;
            }
            if(tmp<target) {
                slow++;
            }
            else{
                fast--;
            }
        }
        if(flag==true) {
            for(int i=0; i<backup.length; i++) {
                if(backup[i]==nums[slow])
                    res[0] = i;
                if(backup[backup.length-1-i]==nums[fast]) {
                    res[1] = backup.length-1-i;
                    
                }
            }
            return res;
        }
        return null;
    }
    
    public int[] deepcopy(int[] data) {
        int[] res = new int[data.length];
        for(int i=0; i<data.length; i++) {
            res[i] = data[i];
        }
        return res;
    }
}
```
