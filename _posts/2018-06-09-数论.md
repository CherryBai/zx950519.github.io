---
layout:     post
title:      数论
subtitle:   数论中的一些常用知识&模板
date:       2018-06-09
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数论
    - 总结 
---

## 最大公约数&最小公倍数

&emsp;&emsp;对于最大公约数和最小公倍数的求解方法，利用辗转相除法(欧几里德算法)即可。先求出最大公约数，再求出最小公倍数。  

```
    // 循环法实现辗转相除
    public static long gcd_1(long a, long b) {
        long k = 0;
        do {
            // 得到余数
            k = a % b;
            // 根据辗转相除法,把被除数赋给除数
            a = b;
            // 余数赋给被除数
            b = k;
        } while(k != 0);
        // 返回被除数
        return a;
    }
    // 循递归法实现辗转相除
    public static long gcd_2(long a, long b) {
        if(b == 0) {
            return a;
        }
        if(a < 0) {
            return gcd_2(-a, b);
        }
        if(b < 0) {
            return gcd_2(a, -b);
        }
        return gcd_2(b, a % b);
    }
```

## 同余与模运算  

```
(a+b) mod n = ((a mod n)+(b mod n)) mod n
(a-b) mod n = ((a mod n)-(b mod n) + n) mod n
(a*b) mod n = (a mod n)(b mod n) mod n
```

## 扩展欧几里得

&emsp;&emsp;扩展欧几里得算法就是在求 a,b 的最大公约数 m=gcd(a,b) 的同时，求出贝祖等式ax + by = m的一个解 (x,y)。  

#### 贝祖等式

&emsp;&emsp;对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程（称为裴蜀等式）:ax + by = m 有整数解时当且仅当m是d的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x, y都称为裴蜀数，可用扩展欧几里得算法(Extended Euclidean algorithm)求得。例如，12和42的最大公因数是6，则方程12x+42y=6有解。事实上有(-3)×12 + 1×42 = 6及4×12 + (-1)×42 = 6。特别来说，方程 ax+by=1 有整数解当且仅当整数a和b互素。

#### 求解二元一次方程的实例(Java)
&emsp;&emsp;递归版  

```
public class Main {

    public static int x = 0;
    public static int y = 0;

    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        int r = exgcd(47, 30);
        System.out.println("r = " + r);
        System.out.println("x = " + x);
        System.out.println("y = " + y);
    }

    public static int exgcd(int a, int b) {
        if(b == 0) {
            x = 1;
            y = 0;
            return a;
        }
        int r = exgcd(b, a%b);
        int t = y;
        y = x - (a/b)*y;
        x = t;
        return r;
    }

}
```

&emsp;&emsp;递归过程为：  

```
exgcd(47, 30, x, y)
 {
     r = exgcd(30, 17，x, y)
     {
         r = exgcd(17, 13, x, y)
         {
             r = exgcd(13, 4, x, y)
             {
                 r = exgcd(4, 1, x, y)
                 {
                     r = exgcd(1, 0, x, y)
                     {
                         x = 1; 
                         y = 0;
                         return 1;
                     }
                     t = y = 0;
                     y = x - (4/1) * y = 1;
                     x = t = 0;
                     return r = 1; 
                 }
                 t = 1;
                 y = 0 - (13/4) * 1 = -3;
                 x = 1;
                 return 1;
             }
             t = -3;
             y = 1 - (17/13) * (-3) = 4;
             x = -3;
             return 1;
         }
         t = 4;
         y = -3 - (30/17) * 4 = -7;
         x = 4;
         return 1;
     }
     t = -7;
     y = 4 - (47/30) * (-7) = 11;
     x = -7;
     return 1;
 }
```
&emsp;&emsp;非递归版  

```
public class Main {

    public static int x = 0;
    public static int y = 0;

    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        int r = exgcdS(47, 30);
        System.out.println("r = " + r);
        System.out.println("x = " + x);
        System.out.println("y = " + y);
    }
    
    public static int exgcdS(int m, int n) {
        if (n == 0) {
            x = 1; y = 0;
            return m;
        }
        int a, a1, b, b1, c, d, q, r, t;
        a1 = b = 1;
        a = b1 = 0;
        c = m; d = n;

        q = c/d;
        r = c%d;
        while (r>0) {
            c = d;
            d = r;
            t = a1;
            a1 = a;
            a = t - q * a;
            t = b1;
            b1 = b;
            b = t - q * b;

            q = c/d;
            r = c%d;
        }
        x = a; y = b;
        return d;
    }

}
```
