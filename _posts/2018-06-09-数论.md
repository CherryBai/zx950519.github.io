---
layout:     post
title:      数论
subtitle:   数论中的一些常用知识&模板
date:       2018-06-09
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 数论
    - 总结 
---

## 最大公约数&最小公倍数

&emsp;&emsp;对于最大公约数和最小公倍数的求解方法，利用辗转相除法(欧几里德算法)即可。先求出最大公约数，再求出最小公倍数。  

```
    // 循环法实现辗转相除
    public static long gcd_1(long a, long b) {
        long k = 0;
        do {
            // 得到余数
            k = a % b;
            // 根据辗转相除法,把被除数赋给除数
            a = b;
            // 余数赋给被除数
            b = k;
        } while(k != 0);
        // 返回被除数
        return a;
    }
    // 循递归法实现辗转相除
    public static long gcd_2(long a, long b) {
        if(b == 0) {
            return a;
        }
        if(a < 0) {
            return gcd_2(-a, b);
        }
        if(b < 0) {
            return gcd_2(a, -b);
        }
        return gcd_2(b, a % b);
    }
```

## 同余与模运算  

```
(a+b) mod n = ((a mod n)+(b mod n)) mod n
(a-b) mod n = ((a mod n)-(b mod n) + n) mod n
(a*b) mod n = (a mod n)(b mod n) mod n
```

## 扩展欧几里得

&emsp;&emsp;扩展欧几里得算法就是在求 a,b 的最大公约数 m=gcd(a,b) 的同时，求出贝祖等式ax + by = m的一个解 (x,y)。  

#### 贝祖等式

&emsp;&emsp;对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程（称为裴蜀等式）:ax + by = m 有整数解时当且仅当m是d的倍数。裴蜀等式有解时必然有无穷多个整数解，每组解x, y都称为裴蜀数，可用扩展欧几里得算法(Extended Euclidean algorithm)求得。例如，12和42的最大公因数是6，则方程12x+42y=6有解。事实上有(-3)×12 + 1×42 = 6及4×12 + (-1)×42 = 6。特别来说，方程 ax+by=1 有整数解当且仅当整数a和b互素。

#### 求解二元一次方程的实例(Java)
&emsp;&emsp;递归版  

```
public class Main {

    public static int x = 0;
    public static int y = 0;

    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        int r = exgcd(47, 30);
        System.out.println("r = " + r);
        System.out.println("x = " + x);
        System.out.println("y = " + y);
    }

    public static int exgcd(int a, int b) {
        if(b == 0) {
            x = 1;
            y = 0;
            return a;
        }
        int r = exgcd(b, a%b);
        int t = y;
        y = x - (a/b)*y;
        x = t;
        return r;
    }

}
```

&emsp;&emsp;递归过程为：  

```
exgcd(47, 30, x, y)
 {
     r = exgcd(30, 17，x, y)
     {
         r = exgcd(17, 13, x, y)
         {
             r = exgcd(13, 4, x, y)
             {
                 r = exgcd(4, 1, x, y)
                 {
                     r = exgcd(1, 0, x, y)
                     {
                         x = 1; 
                         y = 0;
                         return 1;
                     }
                     t = y = 0;
                     y = x - (4/1) * y = 1;
                     x = t = 0;
                     return r = 1; 
                 }
                 t = 1;
                 y = 0 - (13/4) * 1 = -3;
                 x = 1;
                 return 1;
             }
             t = -3;
             y = 1 - (17/13) * (-3) = 4;
             x = -3;
             return 1;
         }
         t = 4;
         y = -3 - (30/17) * 4 = -7;
         x = 4;
         return 1;
     }
     t = -7;
     y = 4 - (47/30) * (-7) = 11;
     x = -7;
     return 1;
 }
```
&emsp;&emsp;非递归版  

```
public class Main {

    public static int x = 0;
    public static int y = 0;

    public static void main(String[] args) throws Exception {
        Scanner scanner = new Scanner(System.in);
        int r = exgcdS(47, 30);
        System.out.println("r = " + r);
        System.out.println("x = " + x);
        System.out.println("y = " + y);
    }
    
    public static int exgcdS(int m, int n) {
        if (n == 0) {
            x = 1; y = 0;
            return m;
        }
        int a, a1, b, b1, c, d, q, r, t;
        a1 = b = 1;
        a = b1 = 0;
        c = m; d = n;

        q = c/d;
        r = c%d;
        while (r>0) {
            c = d;
            d = r;
            t = a1;
            a1 = a;
            a = t - q * a;
            t = b1;
            b1 = b;
            b = t - q * b;

            q = c/d;
            r = c%d;
        }
        x = a; y = b;
        return d;
    }

}
```

#### 乘法逆元  

&emsp;&emsp;就本人目前的认识，乘法逆元主要使用与除法取模的场景中。由于除法取模无法展开，一个解决办法是将除法变成乘法，除了变换运算符号，还要讲除数变成乘数，乘法逆元可以解决将原来的除数怎么变成新的乘数这一过程。例如(12 / 4) mod 7 = 3, 我们可以通过乘法逆元将这个过程变为(12 * 2) mod 7 = 3，这个4->2就是乘法逆元所做的工作。定理为：如果ax≡1 (mod p),且gcd(a,p)=1（a与p互质），则称a关于模p的乘法逆元为x。  

&emsp;&emsp;例如，求5关于模14的乘法逆元，值为2。即(n/5)%14与(n*2)%14结果一致。  

&emsp;&emsp;C++模板：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define LL long long
int inv[1000010];

LL ksm(LL a,LL b,LL mod){
    int ans=1;
    while(b){
        if(b&1) ans=(ans*a)%mod;
        a=(a*a)%mod;
        b>>=1;
    }
    return ans;
} 

LL exgcd(LL a,LL b,LL &x,LL &y){
    if(!b){
        x=1;
        y=0;
        return a;
    }
    LL GCD=exgcd(b,a%b,x,y);
    LL tmp=x;
    x=y;
    y=tmp-a/b*y;
    return GCD;
}

//扩展欧几里得求逆元
LL inv1(LL a,LL mod) {
    LL x,y;
    LL d=exgcd(a,mod,x,y);
    if(d==1) return (x%mod+mod)%mod;
    return -1;
}

//费马小定理
LL inv2(LL a,LL mod){
    return ksm(a,mod-2,mod);
} 

//线性递推求逆元 
void inv3(LL mod){
    inv[1]=1;
    for(int i=2;i<=mod-1;i++){
        inv[i]=(mod-mod/i)*inv[mod%i]%mod;
        cout<<inv[i]<<" ";
    }
}

int main()
{
    LL n,mod;
    while(cin>>n>>mod){
        cout<<inv1(n,mod)<<endl;
    }

} 
```

