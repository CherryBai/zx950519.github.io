---
layout:     post
title:      Java解题模板汇总
subtitle:   Java解题模板汇总
date:       2018-06-25
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Java
    - 解题模板
    - 总结
    - 算法
---

## 精度问题

#### 问题引入
&emsp;&emsp;丫的，前两天做题发现了这么个奇葩的问题，代码如下：  

```
    public class Main {

        public static void main(String[] args) throws Exception {
            System.out.println(0.2 + 0.1);
            System.out.println(0.4 - 0.3);
            System.out.println(0.1 * 0.2);
            System.out.println(0.6 / 0.2);
            System.out.println(4.1 - 1.1);
        }
        //    0.30000000000000004
        //    0.10000000000000003
        //    0.020000000000000004
        //    2.9999999999999996
        //    2.9999999999999996

    }
```  
&emsp;&emsp;尤其是最下面那组4.1-1.1，解题的一个步骤是要求两个数(double类型)差的绝对值，然后向下取整，我直接用Math.floor(Math.abs(4.1-1.1));
发现结果竟然等于2，后来经过网上搜集资料，发现Java在精度上是有问题的！  

#### 理论解释  
&emsp;&emsp;借用《Effactive Java》书中的话，float和double类型的主要设计目标是为了科学计算和工程计算。他们执行二进制浮点运算，这是为了在广域数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们没有提供完全精确的结果，所以不应该被用于要求精确结果的场合。但是，商业计算往往要求结果精确，这时候BigDecimal就派上大用场了。  

&emsp;&emsp;在学习计算机组成原理的时候我们应该都对浮点数有一定的了解，看下这个演示的例子就知道为啥会出现丢失精度的问题：https://www.zhihu.com/question/42024389  

#### 解决办法  
&emsp;&emsp;使用Java中的BigDecimal，主要有如下几种构造方式：  
```
    1.public BigDecimal(double val)    //将double表示形式转换为BigDecimal, 不建议使用

    2.public BigDecimal(int val)　　   //将int表示形式转换成BigDecimal

    3.public BigDecimal(String val)　　//将String表示形式转换成BigDecimal
```  

&emsp;&emsp;为什么不推荐使用double构造BigDecimal对象呢，看下面的实例：  

```
    import java.math.BigDecimal;
    public class Main {

        public static void main(String[] args) throws Exception {
            BigDecimal bigDecimal = new BigDecimal(2);
            BigDecimal bDouble = new BigDecimal(2.3);
            BigDecimal bString = new BigDecimal("2.3");
            System.out.println("bigDecimal=" + bigDecimal);
            System.out.println("bDouble=" + bDouble);
            System.out.println("bString=" + bString);
        }
        //    bigDecimal=2
        //    bDouble=2.29999999999999982236431605997495353221893310546875
        //    bString=2.3

    }
```

&emsp;&emsp;为什么会出现这种情况呢？  

- 1.参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。  

- 2.String 构造方法是完全可预知的：写入 newBigDecimal("0.1") 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。  

&emsp;&emsp;当必须使用double构造时，可以使用String进行过桥，避免丢失精度，例如：BigDecimal b1 = new BigDecimal(Double.toString(v1));
  

#### 加减乘除
```
    public BigDecimal add(BigDecimal value);                        //加法

    public BigDecimal subtract(BigDecimal value);                   //减法 

    public BigDecimal multiply(BigDecimal value);                   //乘法

    public BigDecimal divide(BigDecimal value);                     //除法
```  

&emsp;&emsp;值得注意的是对于除法，如果不能整除，运行时会出现java.lang.ArithmeticException异常，解决办法是添加额外的参数：public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)。其中第一参数表示除数，第二个参数表示小数点后保留位数，第三个参数表示舍入模式，只有在作除法运算或四舍五入时才用到舍入模式，有下面这几种：  

- ROUND_CEILING        //向正无穷方向舍入
- ROUND_DOWN           //向零方向舍入
- ROUND_FLOOR          //向负无穷方向舍入
- ROUND_HALF_DOWN      //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5
- ROUND_HALF_EVEN      //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN
- ROUND_HALF_UP        //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55保留一位小数结果为1.6
- ROUND_UNNECESSARY    //计算结果是精确的，不需要舍入模式
- ROUND_UP             //向远离0的方向舍入  

&emsp;&emsp;例如，常见的四舍五入为：System.out.println("a / b =" + a.divide(b, 10, BigDecimal.ROUND_HALF_UP));  

&emsp;&emsp;此外，四则运算后会产生新的对象，即BigDecimal对象不可变！  

#### 截断操作  
&emsp;&emsp;需要对BigDecimal进行截断和四舍五入可用setScale方法，例如：  

```
    import java.math.*;
    import java.math.BigDecimal;
    public class Main {

        public static void main(String[] args) throws Exception {
            BigDecimal a = new BigDecimal("4.5635");
            a = a.setScale(3, RoundingMode.HALF_UP);    //保留3位小数，且四舍五入
            System.out.println(a);
        }

    }
```
#### 常见变量  

```
    BigDecimal zero = BigDecimal.ZERO;  
    BigDecimal one = BigDecimal.ONE;  
    BigDecimal ten = BigDecimal.TEN; 
```  

#### 比较操作  

```
    BigDecimal one = BigDecimal.valueOf(1);  
    BigDecimal two = BigDecimal.valueOf(2);  
    BigDecimal three = one.add(two);  
    int i1 = one.compareTo(two);//-1  
    int i2 = two.compareTo(two);//0  
    int i3 = three.compareTo(two);//1  
```  

#### 完整API
&emsp;&emsp;地址：http://www.javaweb.cc/help/JavaAPI1.6/java/math/class-use/BigDecimal.html  
  
&emsp;&emsp;地址：https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html

## 源码分析  

&emsp;&emsp;有待补充  

## 解题模板  

```
class Arith{
    private static final int DEF_DIV_SCALE = 10; //这个类不能实例化
    private Arith(){
    }
    /**
     * 提供精确的加法运算。
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1,double v2){
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.add(b2).doubleValue();
    }
    /**
     * 提供精确的减法运算。
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double sub(double v1,double v2){
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.subtract(b2).doubleValue();
    }
    /**
     * 提供精确的乘法运算。
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double mul(double v1,double v2){
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.multiply(b2).doubleValue();
    }
    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double div(double v1,double v2){
        return div(v1,v2,DEF_DIV_SCALE);
    }
    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     * @param v1 被除数
     * @param v2 除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double div(double v1,double v2,int scale){
        if(scale<0){
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.divide(b2,scale,BigDecimal.ROUND_HALF_UP).doubleValue();
    }
    /**
     * 提供精确的小数位四舍五入处理。
     * @param v 需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double v,int scale){
        if(scale<0){
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        BigDecimal b = new BigDecimal(Double.toString(v));
        BigDecimal one = new BigDecimal("1");
        return b.divide(one,scale,BigDecimal.ROUND_HALF_UP).doubleValue();
    }
}
```
