---
layout:     post
title:      Java解题模板汇总
subtitle:   Java解题模板汇总
date:       2018-06-25
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Java
    - 解题模板
    - 总结
    - 算法
---
## 输入问题

&emsp;&emsp;Codeforces著名世界级选手Petr大爷写的Java输入内部类:  
```
class InputReader {
    public BufferedReader reader;
    public StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream), 32768);
        tokenizer = null;
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

}
```

## 输出问题

&emsp;&emsp;文档：https://www.cs.colostate.edu/~cs160/.Summer16/resources/Java_printf_method_quick_reference.pdf  

&emsp;&emsp;常见输出格式：  
```
    // 定义一些变量，用来格式化输出。
    double d = 345.678;
    String s = "你好！";
    int i = 1234;
    // "%"表示进行格式化输出，"%"之后的内容为格式的定义。
    System.out.printf("%f", d);// "f"表示格式化输出浮点数。
    System.out.println();
    System.out.printf("%9.2f", d);// "9.2"中的9表示输出的长度，2表示小数点后的位数。
    System.out.println();
    System.out.printf("%+9.2f", d);// "+"表示输出的数带正负号。
    System.out.println();
    System.out.printf("%-9.4f", d);// "-"表示输出的数左对齐（默认为右对齐）。
    System.out.println();
    System.out.printf("%+-9.3f", d);// "+-"表示输出的数带正负号且左对齐。
    System.out.println();
    System.out.printf("%d", i);// "d"表示输出十进制整数。
    System.out.println();
    System.out.printf("%o", i);// "o"表示输出八进制整数。
    System.out.println();
    System.out.printf("%x", i);// "d"表示输出十六进制整数。
    System.out.println();
    System.out.printf("%#x", i);// "d"表示输出带有十六进制标志的整数。
    System.out.println();
    System.out.printf("%s", s);// "d"表示输出字符串。
    System.out.println();
    System.out.printf("输出一个浮点数：%f，一个整数：%d，一个字符串：%s", d, i, s);
    // 可以输出多个变量，注意顺序。
    System.out.println();
    System.out.printf("字符串：%2$s，%1$d的十六进制数：%1$#x", i, s);
```
```
    345.678000
       345.68
      +345.68
    345.6780 
    +345.678 
    1234
    2322
    4d2
    0x4d2
    你好！
    输出一个浮点数：345.678000，一个整数：1234，一个字符串：你好！
    字符串：你好！，1234的十六进制数：0x4d2
```

## 精度问题

#### 问题分析  

&emsp;&emsp;丫的，前两天做题发现了这么个奇葩的问题，代码如下：  

```
    public class Main {

        public static void main(String[] args) throws Exception {
            System.out.println(0.2 + 0.1);
            System.out.println(0.4 - 0.3);
            System.out.println(0.1 * 0.2);
            System.out.println(0.6 / 0.2);
            System.out.println(4.1 - 1.1);
        }
        //    0.30000000000000004
        //    0.10000000000000003
        //    0.020000000000000004
        //    2.9999999999999996
        //    2.9999999999999996

    }
```  
&emsp;&emsp;尤其是最下面那组4.1-1.1，解题的一个步骤是要求两个数(double类型)差的绝对值，然后向下取整，我直接用Math.floor(Math.abs(4.1-1.1));
发现结果竟然等于2，后来经过网上搜集资料，发现Java在精度上是有问题的！  

理论解释  

&emsp;&emsp;借用《Effactive Java》书中的话，float和double类型的主要设计目标是为了科学计算和工程计算。他们执行二进制浮点运算，这是为了在广域数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们没有提供完全精确的结果，所以不应该被用于要求精确结果的场合。但是，商业计算往往要求结果精确，这时候BigDecimal就派上大用场了。  

&emsp;&emsp;在学习计算机组成原理的时候我们应该都对浮点数有一定的了解，看下这个演示的例子就知道为啥会出现丢失精度的问题：https://www.zhihu.com/question/42024389  

解决办法  

&emsp;&emsp;使用Java中的BigDecimal，主要有如下几种构造方式：  
```
    1.public BigDecimal(double val)    //将double表示形式转换为BigDecimal, 不建议使用

    2.public BigDecimal(int val)　　   //将int表示形式转换成BigDecimal

    3.public BigDecimal(String val)　　//将String表示形式转换成BigDecimal
```  

&emsp;&emsp;为什么不推荐使用double构造BigDecimal对象呢，看下面的实例：  

```
    import java.math.BigDecimal;
    public class Main {

        public static void main(String[] args) throws Exception {
            BigDecimal bigDecimal = new BigDecimal(2);
            BigDecimal bDouble = new BigDecimal(2.3);
            BigDecimal bString = new BigDecimal("2.3");
            System.out.println("bigDecimal=" + bigDecimal);
            System.out.println("bDouble=" + bDouble);
            System.out.println("bString=" + bString);
        }
        //    bigDecimal=2
        //    bDouble=2.29999999999999982236431605997495353221893310546875
        //    bString=2.3

    }
```

&emsp;&emsp;为什么会出现这种情况呢？  

- 1.参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。  

- 2.String 构造方法是完全可预知的：写入 newBigDecimal("0.1") 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。  

&emsp;&emsp;当必须使用double构造时，可以使用String进行过桥，避免丢失精度，例如：BigDecimal b1 = new BigDecimal(Double.toString(v1));
  
加减乘除  

```
    public BigDecimal add(BigDecimal value);                        //加法

    public BigDecimal subtract(BigDecimal value);                   //减法 

    public BigDecimal multiply(BigDecimal value);                   //乘法

    public BigDecimal divide(BigDecimal value);                     //除法
```  

&emsp;&emsp;值得注意的是对于除法，如果不能整除，运行时会出现java.lang.ArithmeticException异常，解决办法是添加额外的参数：public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)。其中第一参数表示除数，第二个参数表示小数点后保留位数，第三个参数表示舍入模式，只有在作除法运算或四舍五入时才用到舍入模式，有下面这几种：  

- ROUND_CEILING        //向正无穷方向舍入
- ROUND_DOWN           //向零方向舍入
- ROUND_FLOOR          //向负无穷方向舍入
- ROUND_HALF_DOWN      //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5
- ROUND_HALF_EVEN      //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN
- ROUND_HALF_UP        //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55保留一位小数结果为1.6
- ROUND_UNNECESSARY    //计算结果是精确的，不需要舍入模式
- ROUND_UP             //向远离0的方向舍入  

&emsp;&emsp;例如，常见的四舍五入为：System.out.println("a / b =" + a.divide(b, 10, BigDecimal.ROUND_HALF_UP));  

&emsp;&emsp;此外，四则运算后会产生新的对象，即BigDecimal对象不可变！  

截断操作  

&emsp;&emsp;需要对BigDecimal进行截断和四舍五入可用setScale方法，例如：  

```
    import java.math.*;
    import java.math.BigDecimal;
    public class Main {

        public static void main(String[] args) throws Exception {
            BigDecimal a = new BigDecimal("4.5635");
            a = a.setScale(3, RoundingMode.HALF_UP);    //保留3位小数，且四舍五入
            System.out.println(a);
        }

    }
```
常见变量  

```
    BigDecimal zero = BigDecimal.ZERO;  
    BigDecimal one = BigDecimal.ONE;  
    BigDecimal ten = BigDecimal.TEN; 
```  

比较操作  

```
    BigDecimal one = BigDecimal.valueOf(1);  
    BigDecimal two = BigDecimal.valueOf(2);  
    BigDecimal three = one.add(two);  
    int i1 = one.compareTo(two);//-1  
    int i2 = two.compareTo(two);//0  
    int i3 = three.compareTo(two);//1  
```  

完整API  

&emsp;&emsp;地址：http://www.javaweb.cc/help/JavaAPI1.6/java/math/class-use/BigDecimal.html  
  
&emsp;&emsp;地址：https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html

源码分析  

&emsp;&emsp;有待补充  

#### 解题模板  

```
class Arith{
    private static final int DEF_DIV_SCALE = 10; //这个类不能实例化
    private Arith(){
    }
    /**
     * 提供精确的加法运算。
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1,double v2){
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.add(b2).doubleValue();
    }
    /**
     * 提供精确的减法运算。
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double sub(double v1,double v2){
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.subtract(b2).doubleValue();
    }
    /**
     * 提供精确的乘法运算。
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double mul(double v1,double v2){
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.multiply(b2).doubleValue();
    }
    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double div(double v1,double v2){
        return div(v1,v2,DEF_DIV_SCALE);
    }
    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     * @param v1 被除数
     * @param v2 除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double div(double v1,double v2,int scale){
        if(scale<0){
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.divide(b2,scale,BigDecimal.ROUND_HALF_UP).doubleValue();
    }
    /**
     * 提供精确的小数位四舍五入处理。
     * @param v 需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double v,int scale){
        if(scale<0){
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        BigDecimal b = new BigDecimal(Double.toString(v));
        BigDecimal one = new BigDecimal("1");
        return b.divide(one,scale,BigDecimal.ROUND_HALF_UP).doubleValue();
    }
}
```

## 类型转换

#### String转double
```
public static boolean isDouble(String data) {
        try{
            double tmp = Double.parseDouble(data);
            return true;
        }
        catch (Exception e) {

        }
        return false;
    }
```

#### ArrayList转int[]
```
class Transformation {

    // ArrayList转int[]
    public static int[] list2Ints(ArrayList<Integer> arrayList){
        return arrayList.stream().mapToInt(i->i).toArray();
    }

}
```

&emsp;&emsp;持续更新中

## 进制转换

&emsp;&emsp;任意进制间的转换，使用10进制进行桥接即可。利用了StringBuilder、取余等操作即可，实现过程如下：
```
import java.util.*;
import java.io.*;
import java.math.*;
public class Main{

    private static char[] array = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
    private static String numStr = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            int from = in.nextInt();
            int to = in.nextInt();
            String input = in.next();
            // 任意进制转任意进制 使用10进制进行桥接
            System.out.println(getData(from, to, input));
        }

    }
    // 获取结果
    public static String getData(int from, int to, String data) {
        Long tmp_10= Hexadecimal_From_Random_To_10(data, from);
        String tmp_random = Hexadecimal_From_10_To_Random(tmp_10, to);
        String ans = tmp_random.replaceFirst("^0*", "");
        return ans;
    }
    // 10进制转任意进制
    public static String Hexadecimal_From_10_To_Random(long data, int N) {
        Long tmp = data;
        Stack<Character> stack = new Stack<Character>();
        StringBuilder result = new StringBuilder(0);
        while (tmp != 0) {
            stack.add(array[new Long((tmp % N)).intValue()]);
            tmp = tmp / N;
        }
        for (; !stack.isEmpty();) {
            result.append(stack.pop());
        }
        return result.length() == 0 ? "0":result.toString();
    }
    // 任意进制转10进制
    public static long Hexadecimal_From_Random_To_10(String number, int N) {
        char ch[] = number.toCharArray();int len = ch.length;
        long result = 0;
        if (N == 10){
            return Long.parseLong(number);
        }
        long base = 1;
        for (int i = len - 1; i >= 0; i--) {
            int index = numStr.indexOf(ch[i]);
            result += index * base;
            base *= N;
        }
        return result;
    }

}
```

## 字典Map的使用

- 1.HashMap
- 2.LinkedHashMap
- 3.TreeMap

&emsp;&emsp;HashMap最基本的Map，遍历时的顺序与插入顺序无关  

&emsp;&emsp;LinkedHashMap是特殊的一种Map，遍历时的顺序与插入顺序相同  

&emsp;&emsp;TreeMap默认是按照key的字典序升序排列，如果想降序的话按照如下操作:  
```
    Map<Integer, Integer> map = new TreeMap<Integer, Integer>(new Comparator<Integer>(){
        /*
         * int compare(Object o1, Object o2) 返回一个基本类型的整型，
         * 返回负数表示：o1 小于o2，
         * 返回0 表示：o1和o2相等，
         * 返回正数表示：o1大于o2。
         */
        public int compare(Integer a,Integer b){
            return b-a;
        }
    });
```

&emsp;&emsp;黑科技：Java8中引入了getOrDefault(key, 找不大时返回的值)方法。  

## 数学问题

#### 数列片段和

&emsp;&emsp;例如，给定数列{0.1, 0.2, 0.3, 0.4}，我们有(0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这10个片段。 给定正整数数列，求出全部片段包含的所有的数之和。如本例中10个片段总和是0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。  

&emsp;&emsp;套路：Sum+=(double)(N-i)*(double)(i+1)*a[i];  

#### 简单约瑟夫问题

&emsp;&emsp;出列问题：令res = 0;for(int i=2;i<=n;i++){res = (res+偏移量)%i};System.out.println((res+1));  

## 日期问题

#### 给定年月日判断是星期几  
```
1.公元一年一月一日为星期一(现在世界各国通用一星期七天的制度。这个制度最早由君士坦丁大帝[Constantine the Great]制定。他在公元321年3月7日正式宣布7天为1周，这个制度一直沿用至今)。
2.算今天到公元一年一月一日有多少天，%7，一周7天，周而复始。
3.每年365天，365=52*7+1，所以，过一年，在算星期的时候，就相当于多了一天。
4.闰年多一天。过一个闰年，在3月及以后就要多加一天。
5.公元一年各月一日的星期：t0[] = {1, 4, 4, 0, 2, 5, 0, 3, 6, 1, 4, 6}。
6.本质：日期+月修正+年修正+闰年修正，模7，得到星期几。
7.我们看上面的常数组t[]，其实就是将t0对应的1、2月-1，其后的-2。这个-2，因为是相对公元一年一月一日，所以y-1、m-1和d-1，其中m-1体现在下标中，y和d合起来就是-2了。前两个月-1，是因为在算闰年的时候，将1、2月的y多减了1，在t中补上。即，t[]不仅仅是月份修正常数，而是一个年月日的综合修正常数。
8.以上这个代码，用常数组隐藏了一些算法细节，使得代码变得相当的帅。
```
```
// 由Tomohiko Sakamoto提供
    public static int dayofweek(int y, int m, int d) {
        int[] t = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
        if(m < 3)
            y--;
        return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;
    }
```


