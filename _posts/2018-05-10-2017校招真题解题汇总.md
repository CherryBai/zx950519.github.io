---
layout:     post
title:      科学上网指南
subtitle:   梯子
date:       2018-05-10
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 校招真题
    - Java
    - 总结
    - 牛客网
---

## Fibonacci数列
题目描述
Fibonacci数列是这样定义的：
F[0] = 0
F[1] = 1
for each i ≥ 2: F[i] = F[i-1] + F[i-2]
因此，Fibonacci数列就形如：0, 1, 1, 2, 3, 5, 8, 13, ...，在Fibonacci数列中的数我们称为Fibonacci数。给你一个N，你想让其变为一个Fibonacci数，每一步你可以把当前数字X变为X-1或者X+1，现在给你一个数N求最少需要多少步可以变为Fibonacci数。
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        Vector<Integer> data = new Vector();
        data.add(0);
        data.add(1);
        int i = 0;
        for(i=2; ;i++) {
            int tmp = data.get(i-2) + data.get(i-1);
            data.add(tmp);
            if(tmp > n) 
                break;
        }
        if(Math.abs(data.get(data.size()-1) - n) > Math.abs(data.get(data.size()-2) - n))
            System.out.println(String.valueOf(Math.abs(data.get(data.size()-2) - n)));
        else
            System.out.println(String.valueOf(Math.abs(data.get(data.size()-1) - n)));
    }
}
```

## 解救小易
题目描述
有一片1000*1000的草地，小易初始站在(1,1)(最左上角的位置)。小易在每一秒会横向或者纵向移动到相邻的草地上吃草(小易不会走出边界)。大反派超超想去捕捉可爱的小易，他手里有n个陷阱。第i个陷阱被安置在横坐标为xi ，纵坐标为yi 的位置上，小易一旦走入一个陷阱，将会被超超捕捉。你为了去解救小易，需要知道小易最少多少秒可能会走入一个陷阱，从而提前解救小易。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bufferedReader.readLine());
        String[] x_index = bufferedReader.readLine().split(" ");
        int[] x_data = new int[num];
        String[] y_index = bufferedReader.readLine().split(" ");
        int[] y_data = new int[num];
        for(int i=0; i<x_index.length; i++) {
            x_data[i] = Integer.parseInt(x_index[i]);
            y_data[i] = Integer.parseInt(y_index[i]);
        }
        int sum = Integer.MAX_VALUE;
        for(int i=0; i<x_data.length; i++) {
            if(x_data[i] + y_data[i] -2<sum)
                sum = x_data[i] + y_data[i] -2;
        }
        System.out.println(sum);
    }
}
```

## 分苹果
题目描述
n 只奶牛坐在一排，每个奶牛拥有 ai 个苹果，现在你要在它们之间转移苹果，使得最后所有奶牛拥有的苹果数都相同，每一次，你只能从一只奶牛身上拿走恰好两个苹果到另一个奶牛上，问最少需要移动多少次可以平分苹果，如果方案不存在输出 -1。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bufferedReader.readLine());
        int[] data = new int[num];
        String[] strings = bufferedReader.readLine().split(" ");
        int sum = 0;
        for(int i=0; i<strings.length; i++) {
            data[i] = Integer.parseInt(strings[i]);
            sum += data[i];
        }
        if(sum%num!=0) {
            System.out.println("-1");
            return;
        }
        if((sum/num)%2==1) {
            for(int i=0; i<data.length; i++) {
                if(data[i]%2==0) {
                    System.out.println("-1");
                    return;
                }
            }
        }else {
            for(int i=0; i<data.length; i++) {
                if(data[i]%2==1) {
                    System.out.println("-1");
                    return;
                }
            }
        }
        int avg = 0;
        for(int i=0; i<data.length; i++) {
            if(data[i]<(sum/num)) {
                avg += ((sum/num)-data[i])/2;
            }
        }
        System.out.println(avg);
    }
}
```

## 两种排序方法
题目描述
考拉有n个字符串字符串，任意两个字符串长度都是不同的。考拉最近学习到有两种字符串的排序方法： 1.根据字符串的字典序排序。例如：
"car" < "carriage" < "cats" < "doggies < "koala"
2.根据字符串的长度排序。例如：
"car" < "cats" < "koala" < "doggies" < "carriage"
考拉想知道自己的这些字符串排列顺序是否满足这两种排序方法，考拉要忙着吃树叶，所以需要你来帮忙验证。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bufferedReader.readLine());
        Vector<String> vector1 = new Vector<>();
        Vector<String> vector2 = new Vector<>();
        Vector<String> vector3 = new Vector<>();
        while(num>0) {
            String tmp = bufferedReader.readLine();
            vector1.add(tmp);
            vector2.add(tmp);
            vector3.add(tmp);
            num--;
        }
        Collections.sort(vector2);
        Collections.sort(vector3, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                if(o1.length() > o2.length())
                    return 1;
                else if(o1.length() < o2.length())
                    return -1;
                else
                    return 0;
            }
        });
        int sum1 = 0;
        int sum2 = 0;
        for(int i=0; i<vector1.size(); i++) {
            if(vector1.get(i)!=vector2.get(i))
                sum1++;
            if(vector1.get(i)!=vector3.get(i))
                sum2++;
        }
        if(sum1>0&&sum2>0)
            System.out.println("none");
        if(sum1==0&&sum2==0)
            System.out.println("both");
        if(sum1==0&&sum2>0)
            System.out.println("lexicographically");
        if(sum1>0&&sum2==0)
            System.out.println("lengths");
    }
}
```
