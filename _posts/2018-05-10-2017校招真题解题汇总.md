---
layout:     post
title:      2017校招真题解题汇总
subtitle:   Java解题记录
date:       2018-05-10
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 校招真题
    - Java
    - 总结
    - 牛客网
---

## Fibonacci数列
题目描述
Fibonacci数列是这样定义的：
F[0] = 0
F[1] = 1
for each i ≥ 2: F[i] = F[i-1] + F[i-2]
因此，Fibonacci数列就形如：0, 1, 1, 2, 3, 5, 8, 13, ...，在Fibonacci数列中的数我们称为Fibonacci数。给你一个N，你想让其变为一个Fibonacci数，每一步你可以把当前数字X变为X-1或者X+1，现在给你一个数N求最少需要多少步可以变为Fibonacci数。
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        Vector<Integer> data = new Vector();
        data.add(0);
        data.add(1);
        int i = 0;
        for(i=2; ;i++) {
            int tmp = data.get(i-2) + data.get(i-1);
            data.add(tmp);
            if(tmp > n) 
                break;
        }
        if(Math.abs(data.get(data.size()-1) - n) > Math.abs(data.get(data.size()-2) - n))
            System.out.println(String.valueOf(Math.abs(data.get(data.size()-2) - n)));
        else
            System.out.println(String.valueOf(Math.abs(data.get(data.size()-1) - n)));
    }
}
```

## 解救小易
题目描述
有一片1000*1000的草地，小易初始站在(1,1)(最左上角的位置)。小易在每一秒会横向或者纵向移动到相邻的草地上吃草(小易不会走出边界)。大反派超超想去捕捉可爱的小易，他手里有n个陷阱。第i个陷阱被安置在横坐标为xi ，纵坐标为yi 的位置上，小易一旦走入一个陷阱，将会被超超捕捉。你为了去解救小易，需要知道小易最少多少秒可能会走入一个陷阱，从而提前解救小易。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bufferedReader.readLine());
        String[] x_index = bufferedReader.readLine().split(" ");
        int[] x_data = new int[num];
        String[] y_index = bufferedReader.readLine().split(" ");
        int[] y_data = new int[num];
        for(int i=0; i<x_index.length; i++) {
            x_data[i] = Integer.parseInt(x_index[i]);
            y_data[i] = Integer.parseInt(y_index[i]);
        }
        int sum = Integer.MAX_VALUE;
        for(int i=0; i<x_data.length; i++) {
            if(x_data[i] + y_data[i] -2<sum)
                sum = x_data[i] + y_data[i] -2;
        }
        System.out.println(sum);
    }
}
```

## 分苹果
题目描述
n 只奶牛坐在一排，每个奶牛拥有 ai 个苹果，现在你要在它们之间转移苹果，使得最后所有奶牛拥有的苹果数都相同，每一次，你只能从一只奶牛身上拿走恰好两个苹果到另一个奶牛上，问最少需要移动多少次可以平分苹果，如果方案不存在输出 -1。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bufferedReader.readLine());
        int[] data = new int[num];
        String[] strings = bufferedReader.readLine().split(" ");
        int sum = 0;
        for(int i=0; i<strings.length; i++) {
            data[i] = Integer.parseInt(strings[i]);
            sum += data[i];
        }
        if(sum%num!=0) {
            System.out.println("-1");
            return;
        }
        if((sum/num)%2==1) {
            for(int i=0; i<data.length; i++) {
                if(data[i]%2==0) {
                    System.out.println("-1");
                    return;
                }
            }
        }else {
            for(int i=0; i<data.length; i++) {
                if(data[i]%2==1) {
                    System.out.println("-1");
                    return;
                }
            }
        }
        int avg = 0;
        for(int i=0; i<data.length; i++) {
            if(data[i]<(sum/num)) {
                avg += ((sum/num)-data[i])/2;
            }
        }
        System.out.println(avg);
    }
}
```

## 两种排序方法
题目描述
考拉有n个字符串字符串，任意两个字符串长度都是不同的。考拉最近学习到有两种字符串的排序方法： 1.根据字符串的字典序排序。例如：
"car" < "carriage" < "cats" < "doggies < "koala"
2.根据字符串的长度排序。例如：
"car" < "cats" < "koala" < "doggies" < "carriage"
考拉想知道自己的这些字符串排列顺序是否满足这两种排序方法，考拉要忙着吃树叶，所以需要你来帮忙验证。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bufferedReader.readLine());
        Vector<String> vector1 = new Vector<>();
        Vector<String> vector2 = new Vector<>();
        Vector<String> vector3 = new Vector<>();
        while(num>0) {
            String tmp = bufferedReader.readLine();
            vector1.add(tmp);
            vector2.add(tmp);
            vector3.add(tmp);
            num--;
        }
        Collections.sort(vector2);
        Collections.sort(vector3, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                if(o1.length() > o2.length())
                    return 1;
                else if(o1.length() < o2.length())
                    return -1;
                else
                    return 0;
            }
        });
        int sum1 = 0;
        int sum2 = 0;
        for(int i=0; i<vector1.size(); i++) {
            if(vector1.get(i)!=vector2.get(i))
                sum1++;
            if(vector1.get(i)!=vector3.get(i))
                sum2++;
        }
        if(sum1>0&&sum2>0)
            System.out.println("none");
        if(sum1==0&&sum2==0)
            System.out.println("both");
        if(sum1==0&&sum2>0)
            System.out.println("lexicographically");
        if(sum1>0&&sum2==0)
            System.out.println("lengths");
    }
}
```

## 求数列的和
题目描述
数列的第一项为n，以后各项为前一项的平方根，求数列的前m项的和。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] strings = bufferedReader.readLine().split(" ");
        double n = Double.parseDouble(strings[0]);
        double m = Double.parseDouble(strings[1]);
        double sum = 0;
        while(m>0) {
            sum += n;
            n = Math.sqrt(n);
            m--;
        }
        System.out.println(String.format("%.2f", sum));
    }
}
```

## 水仙花数
题目描述
春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的： “水仙花数”是指一个三位数，它的各位数字的立方和等于其本身，比如：153=1^3+5^3+3^3。 现在要求输出所有在m和n范围内的水仙花数。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        int start = Integer.parseInt(data[0]);
        int end = Integer.parseInt(data[1]);
        Vector<Integer> vector = new Vector();

        for(int i=start; i<=end; i++) {
            if(func(i))
                vector.add(i);
        }
        if(vector.size()==0)
            System.out.println("no");
        else {
            for(int i=0; i<vector.size(); i++) {
                if(i != 0) 
                    System.out.print(" ");
                System.out.print(vector.get(i));
            }
        }
    }

    public static boolean func(int number) {
        int tmp = 0;
        int factor = number;
        while(factor>0) {
            tmp += (factor%10)*(factor%10)*(factor%10);
            factor /= 10;
        }
        if(tmp==number)
            return true;
        else
            return false;
    }
}
```

## 句子反转
题目描述
给定一个句子（只包含字母和空格）， 将句子中的单词位置反转，单词用空格分割, 单词之间只有一个空格，前后没有空格。 比如： （1） “hello xiao mi”-> “mi xiao hello”
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        Stack<String> stack = new Stack<>();
        for(int i=0; i<data.length; i++) {
            stack.push(data[i]);
        }
        int flag = 0;
        while(!stack.empty()) {
            if(flag > 0)
                System.out.print(" ");
            System.out.print(stack.pop());
            flag++;
        }
    }
}
```

## 统计回文
“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。花花非常喜欢这种拥有对称美的回文串，生日的时候她得到两个礼物分别是字符串A和字符串B。现在她非常好奇有没有办法将字符串B插入字符串A使产生的字符串是一个回文串。你接受花花的请求，帮助她寻找有多少种插入办法可以使新串是一个回文串。如果字符串B插入的位置不同就考虑为不一样的办法。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder stringBuilder_first = new StringBuilder(br.readLine());
        StringBuilder stringBuilder_second = new StringBuilder(br.readLine());
        int sum = 0;
        for(int i=0; i<stringBuilder_first.length(); i++) {
            StringBuilder tmp = new StringBuilder(stringBuilder_first);
            tmp.replace(i, i+1, stringBuilder_second.toString() + String.valueOf(stringBuilder_first.charAt(i)));
            if(JudgeIfReverse(tmp))
                sum++;
        }
        StringBuilder tmp = new StringBuilder(stringBuilder_first);
        tmp.append(stringBuilder_second.toString());
        if(JudgeIfReverse(tmp))
            sum++;
        
        System.out.println(sum);
    }

    public static boolean JudgeIfReverse(StringBuilder stringBuilder) {
        StringBuilder stringBuilder_reverse = new StringBuilder(stringBuilder);
        stringBuilder_reverse.reverse();
        for(int i=0; i<stringBuilder.length(); i++)
            if(stringBuilder.charAt(i) != stringBuilder_reverse.charAt(i))
                return false;
        return true;
    }
}
```
