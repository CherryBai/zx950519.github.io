---
layout:     post
title:      2017校招真题解题汇总
subtitle:   Java解题记录
date:       2018-05-10
author:     Alitria
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 校招真题
    - Java
    - 总结
    - 牛客网
---

## Fibonacci数列
题目描述
Fibonacci数列是这样定义的：
F[0] = 0
F[1] = 1
for each i ≥ 2: F[i] = F[i-1] + F[i-2]
因此，Fibonacci数列就形如：0, 1, 1, 2, 3, 5, 8, 13, ...，在Fibonacci数列中的数我们称为Fibonacci数。给你一个N，你想让其变为一个Fibonacci数，每一步你可以把当前数字X变为X-1或者X+1，现在给你一个数N求最少需要多少步可以变为Fibonacci数。
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        Vector<Integer> data = new Vector();
        data.add(0);
        data.add(1);
        int i = 0;
        for(i=2; ;i++) {
            int tmp = data.get(i-2) + data.get(i-1);
            data.add(tmp);
            if(tmp > n) 
                break;
        }
        if(Math.abs(data.get(data.size()-1) - n) > Math.abs(data.get(data.size()-2) - n))
            System.out.println(String.valueOf(Math.abs(data.get(data.size()-2) - n)));
        else
            System.out.println(String.valueOf(Math.abs(data.get(data.size()-1) - n)));
    }
}
```

## 解救小易
题目描述
有一片1000*1000的草地，小易初始站在(1,1)(最左上角的位置)。小易在每一秒会横向或者纵向移动到相邻的草地上吃草(小易不会走出边界)。大反派超超想去捕捉可爱的小易，他手里有n个陷阱。第i个陷阱被安置在横坐标为xi ，纵坐标为yi 的位置上，小易一旦走入一个陷阱，将会被超超捕捉。你为了去解救小易，需要知道小易最少多少秒可能会走入一个陷阱，从而提前解救小易。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bufferedReader.readLine());
        String[] x_index = bufferedReader.readLine().split(" ");
        int[] x_data = new int[num];
        String[] y_index = bufferedReader.readLine().split(" ");
        int[] y_data = new int[num];
        for(int i=0; i<x_index.length; i++) {
            x_data[i] = Integer.parseInt(x_index[i]);
            y_data[i] = Integer.parseInt(y_index[i]);
        }
        int sum = Integer.MAX_VALUE;
        for(int i=0; i<x_data.length; i++) {
            if(x_data[i] + y_data[i] -2<sum)
                sum = x_data[i] + y_data[i] -2;
        }
        System.out.println(sum);
    }
}
```

## 分苹果
题目描述
n 只奶牛坐在一排，每个奶牛拥有 ai 个苹果，现在你要在它们之间转移苹果，使得最后所有奶牛拥有的苹果数都相同，每一次，你只能从一只奶牛身上拿走恰好两个苹果到另一个奶牛上，问最少需要移动多少次可以平分苹果，如果方案不存在输出 -1。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bufferedReader.readLine());
        int[] data = new int[num];
        String[] strings = bufferedReader.readLine().split(" ");
        int sum = 0;
        for(int i=0; i<strings.length; i++) {
            data[i] = Integer.parseInt(strings[i]);
            sum += data[i];
        }
        if(sum%num!=0) {
            System.out.println("-1");
            return;
        }
        if((sum/num)%2==1) {
            for(int i=0; i<data.length; i++) {
                if(data[i]%2==0) {
                    System.out.println("-1");
                    return;
                }
            }
        }else {
            for(int i=0; i<data.length; i++) {
                if(data[i]%2==1) {
                    System.out.println("-1");
                    return;
                }
            }
        }
        int avg = 0;
        for(int i=0; i<data.length; i++) {
            if(data[i]<(sum/num)) {
                avg += ((sum/num)-data[i])/2;
            }
        }
        System.out.println(avg);
    }
}
```

## 两种排序方法
题目描述
考拉有n个字符串字符串，任意两个字符串长度都是不同的。考拉最近学习到有两种字符串的排序方法： 1.根据字符串的字典序排序。例如：
"car" < "carriage" < "cats" < "doggies < "koala"
2.根据字符串的长度排序。例如：
"car" < "cats" < "koala" < "doggies" < "carriage"
考拉想知道自己的这些字符串排列顺序是否满足这两种排序方法，考拉要忙着吃树叶，所以需要你来帮忙验证。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bufferedReader.readLine());
        Vector<String> vector1 = new Vector<>();
        Vector<String> vector2 = new Vector<>();
        Vector<String> vector3 = new Vector<>();
        while(num>0) {
            String tmp = bufferedReader.readLine();
            vector1.add(tmp);
            vector2.add(tmp);
            vector3.add(tmp);
            num--;
        }
        Collections.sort(vector2);
        Collections.sort(vector3, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                if(o1.length() > o2.length())
                    return 1;
                else if(o1.length() < o2.length())
                    return -1;
                else
                    return 0;
            }
        });
        int sum1 = 0;
        int sum2 = 0;
        for(int i=0; i<vector1.size(); i++) {
            if(vector1.get(i)!=vector2.get(i))
                sum1++;
            if(vector1.get(i)!=vector3.get(i))
                sum2++;
        }
        if(sum1>0&&sum2>0)
            System.out.println("none");
        if(sum1==0&&sum2==0)
            System.out.println("both");
        if(sum1==0&&sum2>0)
            System.out.println("lexicographically");
        if(sum1>0&&sum2==0)
            System.out.println("lengths");
    }
}
```

## 求数列的和
题目描述
数列的第一项为n，以后各项为前一项的平方根，求数列的前m项的和。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] strings = bufferedReader.readLine().split(" ");
        double n = Double.parseDouble(strings[0]);
        double m = Double.parseDouble(strings[1]);
        double sum = 0;
        while(m>0) {
            sum += n;
            n = Math.sqrt(n);
            m--;
        }
        System.out.println(String.format("%.2f", sum));
    }
}
```

## 水仙花数
题目描述
春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的： “水仙花数”是指一个三位数，它的各位数字的立方和等于其本身，比如：153=1^3+5^3+3^3。 现在要求输出所有在m和n范围内的水仙花数。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        int start = Integer.parseInt(data[0]);
        int end = Integer.parseInt(data[1]);
        Vector<Integer> vector = new Vector();

        for(int i=start; i<=end; i++) {
            if(func(i))
                vector.add(i);
        }
        if(vector.size()==0)
            System.out.println("no");
        else {
            for(int i=0; i<vector.size(); i++) {
                if(i != 0) 
                    System.out.print(" ");
                System.out.print(vector.get(i));
            }
        }
    }

    public static boolean func(int number) {
        int tmp = 0;
        int factor = number;
        while(factor>0) {
            tmp += (factor%10)*(factor%10)*(factor%10);
            factor /= 10;
        }
        if(tmp==number)
            return true;
        else
            return false;
    }
}
```

## 句子反转
题目描述
给定一个句子（只包含字母和空格）， 将句子中的单词位置反转，单词用空格分割, 单词之间只有一个空格，前后没有空格。 比如： （1） “hello xiao mi”-> “mi xiao hello”
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        Stack<String> stack = new Stack<>();
        for(int i=0; i<data.length; i++) {
            stack.push(data[i]);
        }
        int flag = 0;
        while(!stack.empty()) {
            if(flag > 0)
                System.out.print(" ");
            System.out.print(stack.pop());
            flag++;
        }
    }
}
```

## 统计回文
“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。花花非常喜欢这种拥有对称美的回文串，生日的时候她得到两个礼物分别是字符串A和字符串B。现在她非常好奇有没有办法将字符串B插入字符串A使产生的字符串是一个回文串。你接受花花的请求，帮助她寻找有多少种插入办法可以使新串是一个回文串。如果字符串B插入的位置不同就考虑为不一样的办法。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder stringBuilder_first = new StringBuilder(br.readLine());
        StringBuilder stringBuilder_second = new StringBuilder(br.readLine());
        int sum = 0;
        for(int i=0; i<stringBuilder_first.length(); i++) {
            StringBuilder tmp = new StringBuilder(stringBuilder_first);
            tmp.replace(i, i+1, stringBuilder_second.toString() + String.valueOf(stringBuilder_first.charAt(i)));
            if(JudgeIfReverse(tmp))
                sum++;
        }
        StringBuilder tmp = new StringBuilder(stringBuilder_first);
        tmp.append(stringBuilder_second.toString());
        if(JudgeIfReverse(tmp))
            sum++;
        
        System.out.println(sum);
    }

    public static boolean JudgeIfReverse(StringBuilder stringBuilder) {
        StringBuilder stringBuilder_reverse = new StringBuilder(stringBuilder);
        stringBuilder_reverse.reverse();
        for(int i=0; i<stringBuilder.length(); i++)
            if(stringBuilder.charAt(i) != stringBuilder_reverse.charAt(i))
                return false;
        return true;
    }
}
```

## 数串
题目描述
设有n个正整数，将他们连接成一排，组成一个最大的多位整数。
如:n=3时，3个整数13,312,343,连成的最大整数为34331213。
如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(bufferedReader.readLine());
        String[] data = bufferedReader.readLine().split(" ");
        Vector<String> vector = new Vector<>();
        for(int i=0; i<data.length; i++) {
            vector.add(data[i]);
        }
        Collections.sort(vector, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                String s1 = o1+""+o2;
                String s2 = o2+""+o1;
                return -s1.compareTo(s2);
            }
        });
        String ans = new String("");

        for(int i=0; i<vector.size(); i++) {
            ans += vector.get(i);
        }
        System.out.println(ans);
    }
}
```

## 素数对
题目描述
给定一个正整数，编写程序计算有多少对质数的和等于输入的这个正整数，并输出结果。输入值小于1000。
如，输入为10, 程序应该输出结果为2。（共有两对质数的和为10,分别为(5,5),(3,7)）
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(bufferedReader.readLine());
        int sum = 0;
        Vector<Integer> vector = getPrimeVectorData(size);
        for(int i=0; i<vector.size(); i++) {
            for(int j=i; j<vector.size(); j++) {
                if(vector.get(i)+vector.get(j)>size) {
                    break;
                }
                if(vector.get(i)+vector.get(j)==size) {
                    sum++;
//                    System.out.println(vector.get(i)+"---"+vector.get(j));
                }

            }
        }
        System.out.println(sum);
    }

    public static Vector<Integer> getPrimeVectorData(int size) {
        boolean[] data = new boolean[size+1];
        for(int i=2; i<=size/2; i++) {
            int factor = 2;
            while(true) {
                if(i*factor<=size) {
                    data[i*factor] = true;
                }
                else {
                    break;
                }
                factor++;
            }
        }
        Vector<Integer> vector = new Vector<>();
        for(int i=2; i<=size; i++) {
            if(data[i] == false)
                vector.add(i);
        }
//        System.out.println(vector);
        return vector;
    }
}
```

## 幸运数
题目描述
小明同学学习了不同的进制之后，拿起了一些数字做起了游戏。小明同学知道，在日常生活中我们最常用的是十进制数，而在计算机中，二进制数也很常用。现在对于一个数字x，小明同学定义出了两个函数f(x)和g(x)。 f(x)表示把x这个数用十进制写出后各个数位上的数字之和。如f(123)=1+2+3=6。 g(x)表示把x这个数用二进制写出后各个数位上的数字之和。如123的二进制表示为1111011，那么，g(123)=1+1+1+1+0+1+1=6。 小明同学发现对于一些正整数x满足f(x)=g(x)，他把这种数称为幸运数，现在他想知道，小于等于n的幸运数有多少个？
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(bufferedReader.readLine());
        int sum = 0;

        for(int i=1; i<=num; i++) {
            if(f(i) == g(i)) {
                sum++;
//                System.out.println(f(i)+"-"+g(i)+"-");
            }

        }
        System.out.println(sum);
    }

    public static int f(int num) {
        int ans = 0;
        while(num>0) {
            ans += num % 10;
            num /= 10;
        }
        return ans;
    }

    public static int g(int num){
        StringBuilder stringBuilder = new StringBuilder(Integer.toBinaryString(num));
        int ans = 0;
        for(int i=0; i<stringBuilder.length(); i++) {
            ans += stringBuilder.charAt(i)-'0';
        }
        return ans;
    }

}
```

## 删除公共字符
题目描述
输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。例如，输入”They are students.”和”aeiou”，则删除之后的第一个字符串变成”Thy r stdnts.”
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder first = new StringBuilder(bufferedReader.readLine());
        StringBuilder second = new StringBuilder(bufferedReader.readLine());

        Map<Character, Integer> mmp = new HashMap();
        for(int i=0; i<second.length(); i++) {
            mmp.put(second.charAt(i), 1);
        }
        char[] ans = new char[first.length()];
        int index = 0;
        for(int i=0; i<first.length(); i++) {
            //未找到
            if(mmp.getOrDefault(first.charAt(i), 0) == 0) {
                ans[index++] = first.charAt(i);
            }
        }
        System.out.println(ans);
    }
}
```

## 数字翻转
题目描述
对于一个整数X，定义操作rev(X)为将X按数位翻转过来，并且去除掉前导0。例如:
如果 X = 123，则rev(X) = 321;
如果 X = 100，则rev(X) = 1.
现在给出整数x和y,要求rev(rev(x) + rev(y))为多少？
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        System.out.println(rev(rev(Integer.parseInt(data[1]))+rev(Integer.parseInt(data[0]))));
    }

    public static int rev(int x) {
        return Integer.parseInt(new StringBuilder(String.valueOf(x)).reverse().toString());
    }
}
```
## 最大的奇约数
题目描述
小易是一个数论爱好者，并且对于一个数的奇数约数十分感兴趣。一天小易遇到这样一个问题： 定义函数f(x)为x最大的奇数约数，x为正整数。 例如:f(44) = 11.
现在给出一个N，需要求出 f(1) + f(2) + f(3).......f(N)
例如： N = 7 
f(1) + f(2) + f(3) + f(4) + f(5) + f(6) + f(7) = 1 + 1 + 3 + 1 + 5 + 3 + 7 = 21
小易计算这个问题遇到了困难，需要你来设计一个算法帮助他。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        long size = Long.parseLong(bufferedReader.readLine());
        long sum = 0;
        for(long i=size; i>0; i/=2) {
            long tmp = (1+i)/2;
            sum += tmp*tmp;
        }
        System.out.println(sum);
    }
}
```

## n个数里出现次数大于等于n/2的数
题目描述
输入n个整数，输出出现次数大于等于数组长度一半的数。
```
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        Map<Integer, Integer> mmp = new HashMap<>();
        for(int i=0;i <data.length; i++) {
            mmp.put(Integer.parseInt(data[i]), mmp.getOrDefault(Integer.parseInt(data[i]), 0)+1);
        }
        for(Map.Entry<Integer, Integer> entry: mmp.entrySet()) {
            if(entry.getValue() >= (data.length)/2)
                System.out.println(entry.getKey());
        }
    }
}
```

## 下厨房
题目描述
牛牛想尝试一些新的料理，每个料理需要一些不同的材料，问完成所有的料理需要准备多少种不同的材料。
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        Map<String, Integer> mmp = new HashMap<>();
        String data = bufferedReader.readLine();
        int sum = 0;
        while(data != null) {
            String[] tmp = data.split(" ");
            for(int i=0; i<tmp.length; i++) {
                // 新材料
                if(mmp.getOrDefault(tmp[i], 0) == 0) {
                    mmp.put(tmp[i], 1);
                    ++sum;
                }
            }
            data = bufferedReader.readLine();
        }
        System.out.println(sum);
    }
}
```

## 不要二
题目描述
二货小易有一个W*H的网格盒子，网格的行编号为0~H-1，网格的列编号为0~W-1。每个格子至多可以放一块蛋糕，任意两块蛋糕的欧几里得距离不能等于2。
对于两个格子坐标(x1,y1),(x2,y2)的欧几里得距离为:
( (x1-x2) * (x1-x2) + (y1-y2) * (y1-y2) ) 的算术平方根
小易想知道最多可以放多少块蛋糕在网格盒子里。
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        int w = Integer.parseInt(data[0]);
        int h = Integer.parseInt(data[1]);

        boolean[][] martix = new boolean[w+1][h+1];
        for(int i=1; i<=w; i++) {
            for (int j=1; j<=h; j++) {
                if(martix[i][j]==true){
                }
                else {
                    // 右
                    if(j+2<=h )
                        martix[i][j+2] = true;
                    // 下
                    if(i+2<=w )
                        martix[i+2][j] = true;
                }
            }
        }
        int sum = 0;
        for(int i=1; i<=w; i++) {
            for (int j=1; j<=h; j++) {
                if(martix[i][j]==false){
                    //System.out.println(i+"--"+j);
                    sum++;
                }

            }
        }
        System.out.println(sum);
    }
}
```

## 藏宝图
题目描述
牛牛拿到了一个藏宝图，顺着藏宝图的指示，牛牛发现了一个藏宝盒，藏宝盒上有一个机关，机关每次会显示两个字符串 s 和 t，根据古老的传说，牛牛需要每次都回答 t 是否是 s 的子序列。注意，子序列不要求在原字符串中是连续的，例如串 abc，它的子序列就有 {空串, a, b, c, ab, ac, bc, abc} 8 种。
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        char[] data1 = (bufferedReader.readLine()).toCharArray();
        char[] data2 = (bufferedReader.readLine()).toCharArray();
        if(data2.length > data1.length) {
            System.out.println("No");
            return;
        }
        int tick = 0;
        int index = 0;
        int last_data1 = 0;
        for(int j=0; j<data2.length; j++) {
            index = j;
            for(int i=last_data1; i<data1.length; i++) {
                if(data2[j]==data1[i]) {
//                    System.out.println(i);
                    tick++;
                    last_data1 = i+1;
                    break;
                }
                else {
                    index++;
                }
                if(index==data1.length) {
                    System.out.println("No");
                    return;
                }
            }

        }
        if(tick==data2.length)
            System.out.println("Yes");
        else
            System.out.println("No");
    }
}
```

## 星际穿越
题目描述
航天飞行器是一项复杂而又精密的仪器，飞行器的损耗主要集中在发射和降落的过程，科学家根据实验数据估计，如果在发射过程中，产生了 x 程度的损耗，那么在降落的过程中就会产生 x2 程度的损耗，如果飞船的总损耗超过了它的耐久度，飞行器就会爆炸坠毁。问一艘耐久度为 h 的飞行器，假设在飞行过程中不产生损耗，那么为了保证其可以安全的到达目的地，只考虑整数解，至多发射过程中可以承受多少程度的损耗？
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        Long data = Long.parseLong(bufferedReader.readLine());
        if(data<=1) {
            System.out.println(0);
            return;
        }
        if(data==2) {
            System.out.println(1);
            return;
        }
        Long max = data;
        data = Math.round(Math.sqrt(data));
        //System.out.println(data);
        for(Long i=data; i>0; i--) {
            if(i*i+i <= max) {
                System.out.println(i);
                break;
            }
        }
    }
}
```

## 优雅的点
题目描述
小易有一个圆心在坐标原点的圆，小易知道圆的半径的平方。小易认为在圆上的点而且横纵坐标都是整数的点是优雅的，小易现在想寻找一个算法计算出优雅的点的个数，请你来帮帮他。
例如：半径的平方如果为25
优雅的点就有：(+/-3, +/-4), (+/-4, +/-3), (0, +/-5) (+/-5, 0)，一共12个点。
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(bufferedReader.readLine());
        int sum = 0;
        double tmp = Math.sqrt(size);
        for(int i=0; i<tmp; i++) {
            double tp = Math.sqrt(size - i*i);
            if(Math.abs(tp-Math.round(tp)) < 1e-8) {
                sum++;
            }
        }
        System.out.println(sum*4);
    }
}
```

## 计算糖果
题目描述
A,B,C三个人是好朋友,每个人手里都有一些糖果,我们不知道他们每个人手上具体有多少个糖果,但是我们知道以下的信息：
A - B, B - C, A + B, B + C. 这四个数值.每个字母代表每个人所拥有的糖果数.
现在需要通过这四个数值计算出每个人手里有多少个糖果,即A,B,C。这里保证最多只有一组整数A,B,C满足所有题设条件。
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        int v1 = Integer.parseInt(data[0]);int v2 = Integer.parseInt(data[1]);
        int v3 = Integer.parseInt(data[2]);int v4 = Integer.parseInt(data[3]);
        if((1.0)*(v1 + v3)/2-(v1 + v3)/2 > 1e-8) {
            System.out.println("No");
            return;
        }
        int temp1 = (v1 + v3)/2;
        if((1.0)*(v2 + v4)/2-(v2 + v4)/2 > 1e-8) {
            System.out.println("No");
            return;
        }
        int temp2 = (v2 + v4)/2;
        if(temp1+temp2!=v3) {
            System.out.println("No");
            return;
        }
        int temp3 = v4 - temp2;
        System.out.println(temp1+" "+temp2+" "+temp3);
    }
}
```

## 倒置字符串
题目描述
将一句话的单词进行倒置，标点不倒置。比如 I like beijing. 经过函数后变为：beijing. like I
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        Stack<String> stack = new Stack<>();
        for(int i=0; i<data.length; i++) {
            stack.push(data[i]);
        }
        int index = 0;
        while (!stack.empty()) {
            if(index!=0)
                System.out.print(" ");
            System.out.print(stack.pop());
            index++;
        }
    }
}
```

## 统计字符
题目描述
给定一个英文字符串,请写一段代码找出这个字符串中首先出现三次的那个英文字符。
```
import java.util.*;
import java.io.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        Map<Character, Integer> mmp = new HashMap<>();
        for(int i=0; i<data.length; i++) {
            char[] tmp = data[i].toCharArray();
            for(int j=0; j<tmp.length; j++) {
                int c = (int)tmp[j];
                if((c>=65&&c<=90)||(c>=97&&c<=122)){}
                else {
//                    System.out.println(tmp[j]);
                    continue;
                }
                if(mmp.getOrDefault(tmp[j], 0) ==2) {
                    System.out.println(tmp[j]);
                    return;
                }
                else {
                    mmp.put(tmp[j], mmp.getOrDefault(tmp[j], 0)+1);
                }
            }
        }
    }
}
```

## 整数加法
题目描述
请设计一个算法能够完成两个用字符串存储的整数进行相加操作，对非法的输入则返回error
```
import java.util.*;
import java.io.*;
import java.math.*;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        String[] data = bufferedReader.readLine().split(" ");
        if(!(judge(data[0])&&judge(data[1]))) {
            System.out.println("error");
            return;
        }
        BigInteger b = new BigInteger(data[0]).add(new BigInteger(data[1]));
        System.out.println(b);
    }

    public static boolean judge(String data) {
        char[] tmp = data.toCharArray();
        for(int i=0; i<tmp.length; i++) {
            int tp = (int)tmp[i];
            if(tp<48 || tp>57)
                return false;
        }
        return true;
    }
}
```
